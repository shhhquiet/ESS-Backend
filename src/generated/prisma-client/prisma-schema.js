module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AccountAdmin {
  id: ID!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  phone: String!
  address: String!
  city: String!
  state: String!
  zip: Int!
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
  stripeId: String
  resetToken: String
  resetTokenExpiry: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountAdminConnection {
  pageInfo: PageInfo!
  edges: [AccountAdminEdge]!
  aggregate: AggregateAccountAdmin!
}

input AccountAdminCreateInput {
  id: ID
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  phone: String!
  address: String!
  city: String!
  state: String!
  zip: Int!
  students: StudentCreateManyWithoutAdminInput
  stripeId: String
  resetToken: String
  resetTokenExpiry: String
}

input AccountAdminCreateOneWithoutStudentsInput {
  create: AccountAdminCreateWithoutStudentsInput
  connect: AccountAdminWhereUniqueInput
}

input AccountAdminCreateWithoutStudentsInput {
  id: ID
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  phone: String!
  address: String!
  city: String!
  state: String!
  zip: Int!
  stripeId: String
  resetToken: String
  resetTokenExpiry: String
}

type AccountAdminEdge {
  node: AccountAdmin!
  cursor: String!
}

enum AccountAdminOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  phone_ASC
  phone_DESC
  address_ASC
  address_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  zip_ASC
  zip_DESC
  stripeId_ASC
  stripeId_DESC
  resetToken_ASC
  resetToken_DESC
  resetTokenExpiry_ASC
  resetTokenExpiry_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AccountAdminPreviousValues {
  id: ID!
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  phone: String!
  address: String!
  city: String!
  state: String!
  zip: Int!
  stripeId: String
  resetToken: String
  resetTokenExpiry: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountAdminSubscriptionPayload {
  mutation: MutationType!
  node: AccountAdmin
  updatedFields: [String!]
  previousValues: AccountAdminPreviousValues
}

input AccountAdminSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AccountAdminWhereInput
  AND: [AccountAdminSubscriptionWhereInput!]
  OR: [AccountAdminSubscriptionWhereInput!]
  NOT: [AccountAdminSubscriptionWhereInput!]
}

input AccountAdminUpdateInput {
  email: String
  password: String
  firstName: String
  lastName: String
  phone: String
  address: String
  city: String
  state: String
  zip: Int
  students: StudentUpdateManyWithoutAdminInput
  stripeId: String
  resetToken: String
  resetTokenExpiry: String
}

input AccountAdminUpdateManyMutationInput {
  email: String
  password: String
  firstName: String
  lastName: String
  phone: String
  address: String
  city: String
  state: String
  zip: Int
  stripeId: String
  resetToken: String
  resetTokenExpiry: String
}

input AccountAdminUpdateOneWithoutStudentsInput {
  create: AccountAdminCreateWithoutStudentsInput
  update: AccountAdminUpdateWithoutStudentsDataInput
  upsert: AccountAdminUpsertWithoutStudentsInput
  delete: Boolean
  disconnect: Boolean
  connect: AccountAdminWhereUniqueInput
}

input AccountAdminUpdateWithoutStudentsDataInput {
  email: String
  password: String
  firstName: String
  lastName: String
  phone: String
  address: String
  city: String
  state: String
  zip: Int
  stripeId: String
  resetToken: String
  resetTokenExpiry: String
}

input AccountAdminUpsertWithoutStudentsInput {
  update: AccountAdminUpdateWithoutStudentsDataInput!
  create: AccountAdminCreateWithoutStudentsInput!
}

input AccountAdminWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zip: Int
  zip_not: Int
  zip_in: [Int!]
  zip_not_in: [Int!]
  zip_lt: Int
  zip_lte: Int
  zip_gt: Int
  zip_gte: Int
  students_every: StudentWhereInput
  students_some: StudentWhereInput
  students_none: StudentWhereInput
  stripeId: String
  stripeId_not: String
  stripeId_in: [String!]
  stripeId_not_in: [String!]
  stripeId_lt: String
  stripeId_lte: String
  stripeId_gt: String
  stripeId_gte: String
  stripeId_contains: String
  stripeId_not_contains: String
  stripeId_starts_with: String
  stripeId_not_starts_with: String
  stripeId_ends_with: String
  stripeId_not_ends_with: String
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: String
  resetTokenExpiry_not: String
  resetTokenExpiry_in: [String!]
  resetTokenExpiry_not_in: [String!]
  resetTokenExpiry_lt: String
  resetTokenExpiry_lte: String
  resetTokenExpiry_gt: String
  resetTokenExpiry_gte: String
  resetTokenExpiry_contains: String
  resetTokenExpiry_not_contains: String
  resetTokenExpiry_starts_with: String
  resetTokenExpiry_not_starts_with: String
  resetTokenExpiry_ends_with: String
  resetTokenExpiry_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AccountAdminWhereInput!]
  OR: [AccountAdminWhereInput!]
  NOT: [AccountAdminWhereInput!]
}

input AccountAdminWhereUniqueInput {
  id: ID
  email: String
}

type AgeGroup {
  id: ID!
  name: String!
  minAge: Int!
  maxAge: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AgeGroupConnection {
  pageInfo: PageInfo!
  edges: [AgeGroupEdge]!
  aggregate: AggregateAgeGroup!
}

input AgeGroupCreateInput {
  id: ID
  name: String!
  minAge: Int!
  maxAge: Int
}

input AgeGroupCreateOneInput {
  create: AgeGroupCreateInput
  connect: AgeGroupWhereUniqueInput
}

type AgeGroupEdge {
  node: AgeGroup!
  cursor: String!
}

enum AgeGroupOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  minAge_ASC
  minAge_DESC
  maxAge_ASC
  maxAge_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AgeGroupPreviousValues {
  id: ID!
  name: String!
  minAge: Int!
  maxAge: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AgeGroupSubscriptionPayload {
  mutation: MutationType!
  node: AgeGroup
  updatedFields: [String!]
  previousValues: AgeGroupPreviousValues
}

input AgeGroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AgeGroupWhereInput
  AND: [AgeGroupSubscriptionWhereInput!]
  OR: [AgeGroupSubscriptionWhereInput!]
  NOT: [AgeGroupSubscriptionWhereInput!]
}

input AgeGroupUpdateDataInput {
  name: String
  minAge: Int
  maxAge: Int
}

input AgeGroupUpdateInput {
  name: String
  minAge: Int
  maxAge: Int
}

input AgeGroupUpdateManyMutationInput {
  name: String
  minAge: Int
  maxAge: Int
}

input AgeGroupUpdateOneRequiredInput {
  create: AgeGroupCreateInput
  update: AgeGroupUpdateDataInput
  upsert: AgeGroupUpsertNestedInput
  connect: AgeGroupWhereUniqueInput
}

input AgeGroupUpsertNestedInput {
  update: AgeGroupUpdateDataInput!
  create: AgeGroupCreateInput!
}

input AgeGroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  minAge: Int
  minAge_not: Int
  minAge_in: [Int!]
  minAge_not_in: [Int!]
  minAge_lt: Int
  minAge_lte: Int
  minAge_gt: Int
  minAge_gte: Int
  maxAge: Int
  maxAge_not: Int
  maxAge_in: [Int!]
  maxAge_not_in: [Int!]
  maxAge_lt: Int
  maxAge_lte: Int
  maxAge_gt: Int
  maxAge_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AgeGroupWhereInput!]
  OR: [AgeGroupWhereInput!]
  NOT: [AgeGroupWhereInput!]
}

input AgeGroupWhereUniqueInput {
  id: ID
}

type AggregateAccountAdmin {
  count: Int!
}

type AggregateAgeGroup {
  count: Int!
}

type AggregateClass {
  count: Int!
}

type AggregateEmployee {
  count: Int!
}

type AggregateLesson {
  count: Int!
}

type AggregateMedicalCondition {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Class {
  id: ID!
  name: String
  description: String!
  ageGroup: AgeGroup!
  level: SkillLevel!
  capacity: Int!
  price: Int!
  day: Day!
  instructor: Employee!
  duration: Int!
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
  time: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ClassConnection {
  pageInfo: PageInfo!
  edges: [ClassEdge]!
  aggregate: AggregateClass!
}

input ClassCreateInput {
  id: ID
  name: String
  description: String!
  ageGroup: AgeGroupCreateOneInput!
  level: SkillLevel!
  capacity: Int!
  price: Int!
  day: Day!
  instructor: EmployeeCreateOneWithoutClassesInput!
  duration: Int!
  students: StudentCreateManyWithoutClassesInput
  time: DateTime!
}

input ClassCreateManyWithoutInstructorInput {
  create: [ClassCreateWithoutInstructorInput!]
  connect: [ClassWhereUniqueInput!]
}

input ClassCreateManyWithoutStudentsInput {
  create: [ClassCreateWithoutStudentsInput!]
  connect: [ClassWhereUniqueInput!]
}

input ClassCreateWithoutInstructorInput {
  id: ID
  name: String
  description: String!
  ageGroup: AgeGroupCreateOneInput!
  level: SkillLevel!
  capacity: Int!
  price: Int!
  day: Day!
  duration: Int!
  students: StudentCreateManyWithoutClassesInput
  time: DateTime!
}

input ClassCreateWithoutStudentsInput {
  id: ID
  name: String
  description: String!
  ageGroup: AgeGroupCreateOneInput!
  level: SkillLevel!
  capacity: Int!
  price: Int!
  day: Day!
  instructor: EmployeeCreateOneWithoutClassesInput!
  duration: Int!
  time: DateTime!
}

type ClassEdge {
  node: Class!
  cursor: String!
}

enum ClassOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  level_ASC
  level_DESC
  capacity_ASC
  capacity_DESC
  price_ASC
  price_DESC
  day_ASC
  day_DESC
  duration_ASC
  duration_DESC
  time_ASC
  time_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClassPreviousValues {
  id: ID!
  name: String
  description: String!
  level: SkillLevel!
  capacity: Int!
  price: Int!
  day: Day!
  duration: Int!
  time: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ClassScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  level: SkillLevel
  level_not: SkillLevel
  level_in: [SkillLevel!]
  level_not_in: [SkillLevel!]
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClassScalarWhereInput!]
  OR: [ClassScalarWhereInput!]
  NOT: [ClassScalarWhereInput!]
}

type ClassSubscriptionPayload {
  mutation: MutationType!
  node: Class
  updatedFields: [String!]
  previousValues: ClassPreviousValues
}

input ClassSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassWhereInput
  AND: [ClassSubscriptionWhereInput!]
  OR: [ClassSubscriptionWhereInput!]
  NOT: [ClassSubscriptionWhereInput!]
}

input ClassUpdateInput {
  name: String
  description: String
  ageGroup: AgeGroupUpdateOneRequiredInput
  level: SkillLevel
  capacity: Int
  price: Int
  day: Day
  instructor: EmployeeUpdateOneRequiredWithoutClassesInput
  duration: Int
  students: StudentUpdateManyWithoutClassesInput
  time: DateTime
}

input ClassUpdateManyDataInput {
  name: String
  description: String
  level: SkillLevel
  capacity: Int
  price: Int
  day: Day
  duration: Int
  time: DateTime
}

input ClassUpdateManyMutationInput {
  name: String
  description: String
  level: SkillLevel
  capacity: Int
  price: Int
  day: Day
  duration: Int
  time: DateTime
}

input ClassUpdateManyWithoutInstructorInput {
  create: [ClassCreateWithoutInstructorInput!]
  delete: [ClassWhereUniqueInput!]
  connect: [ClassWhereUniqueInput!]
  set: [ClassWhereUniqueInput!]
  disconnect: [ClassWhereUniqueInput!]
  update: [ClassUpdateWithWhereUniqueWithoutInstructorInput!]
  upsert: [ClassUpsertWithWhereUniqueWithoutInstructorInput!]
  deleteMany: [ClassScalarWhereInput!]
  updateMany: [ClassUpdateManyWithWhereNestedInput!]
}

input ClassUpdateManyWithoutStudentsInput {
  create: [ClassCreateWithoutStudentsInput!]
  delete: [ClassWhereUniqueInput!]
  connect: [ClassWhereUniqueInput!]
  set: [ClassWhereUniqueInput!]
  disconnect: [ClassWhereUniqueInput!]
  update: [ClassUpdateWithWhereUniqueWithoutStudentsInput!]
  upsert: [ClassUpsertWithWhereUniqueWithoutStudentsInput!]
  deleteMany: [ClassScalarWhereInput!]
  updateMany: [ClassUpdateManyWithWhereNestedInput!]
}

input ClassUpdateManyWithWhereNestedInput {
  where: ClassScalarWhereInput!
  data: ClassUpdateManyDataInput!
}

input ClassUpdateWithoutInstructorDataInput {
  name: String
  description: String
  ageGroup: AgeGroupUpdateOneRequiredInput
  level: SkillLevel
  capacity: Int
  price: Int
  day: Day
  duration: Int
  students: StudentUpdateManyWithoutClassesInput
  time: DateTime
}

input ClassUpdateWithoutStudentsDataInput {
  name: String
  description: String
  ageGroup: AgeGroupUpdateOneRequiredInput
  level: SkillLevel
  capacity: Int
  price: Int
  day: Day
  instructor: EmployeeUpdateOneRequiredWithoutClassesInput
  duration: Int
  time: DateTime
}

input ClassUpdateWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput!
  data: ClassUpdateWithoutInstructorDataInput!
}

input ClassUpdateWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput!
  data: ClassUpdateWithoutStudentsDataInput!
}

input ClassUpsertWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput!
  update: ClassUpdateWithoutInstructorDataInput!
  create: ClassCreateWithoutInstructorInput!
}

input ClassUpsertWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput!
  update: ClassUpdateWithoutStudentsDataInput!
  create: ClassCreateWithoutStudentsInput!
}

input ClassWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  ageGroup: AgeGroupWhereInput
  level: SkillLevel
  level_not: SkillLevel
  level_in: [SkillLevel!]
  level_not_in: [SkillLevel!]
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  instructor: EmployeeWhereInput
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  students_every: StudentWhereInput
  students_some: StudentWhereInput
  students_none: StudentWhereInput
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClassWhereInput!]
  OR: [ClassWhereInput!]
  NOT: [ClassWhereInput!]
}

input ClassWhereUniqueInput {
  id: ID
}

scalar DateTime

enum Day {
  SUNDAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
}

type Employee {
  id: ID!
  email: String!
  password: String!
  phone: String!
  firstName: String!
  lastName: String!
  gender: Gender!
  address: String!
  city: String!
  state: String!
  zip: Int!
  bio: String!
  role: [Role!]!
  imageURL: String!
  startDate: DateTime!
  currentEmployee: Boolean!
  clients(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class!]
  lessons(where: LessonWhereInput, orderBy: LessonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lesson!]
  lessonSinglePrice: Int
  lessonDoublePrice: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EmployeeConnection {
  pageInfo: PageInfo!
  edges: [EmployeeEdge]!
  aggregate: AggregateEmployee!
}

input EmployeeCreateInput {
  id: ID
  email: String!
  password: String!
  phone: String!
  firstName: String!
  lastName: String!
  gender: Gender!
  address: String!
  city: String!
  state: String!
  zip: Int!
  bio: String!
  role: EmployeeCreateroleInput
  imageURL: String!
  startDate: DateTime!
  currentEmployee: Boolean
  clients: StudentCreateManyInput
  classes: ClassCreateManyWithoutInstructorInput
  lessons: LessonCreateManyWithoutInstructorInput
  lessonSinglePrice: Int
  lessonDoublePrice: Int
}

input EmployeeCreateOneWithoutClassesInput {
  create: EmployeeCreateWithoutClassesInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateOneWithoutLessonsInput {
  create: EmployeeCreateWithoutLessonsInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateroleInput {
  set: [Role!]
}

input EmployeeCreateWithoutClassesInput {
  id: ID
  email: String!
  password: String!
  phone: String!
  firstName: String!
  lastName: String!
  gender: Gender!
  address: String!
  city: String!
  state: String!
  zip: Int!
  bio: String!
  role: EmployeeCreateroleInput
  imageURL: String!
  startDate: DateTime!
  currentEmployee: Boolean
  clients: StudentCreateManyInput
  lessons: LessonCreateManyWithoutInstructorInput
  lessonSinglePrice: Int
  lessonDoublePrice: Int
}

input EmployeeCreateWithoutLessonsInput {
  id: ID
  email: String!
  password: String!
  phone: String!
  firstName: String!
  lastName: String!
  gender: Gender!
  address: String!
  city: String!
  state: String!
  zip: Int!
  bio: String!
  role: EmployeeCreateroleInput
  imageURL: String!
  startDate: DateTime!
  currentEmployee: Boolean
  clients: StudentCreateManyInput
  classes: ClassCreateManyWithoutInstructorInput
  lessonSinglePrice: Int
  lessonDoublePrice: Int
}

type EmployeeEdge {
  node: Employee!
  cursor: String!
}

enum EmployeeOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  phone_ASC
  phone_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  gender_ASC
  gender_DESC
  address_ASC
  address_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  zip_ASC
  zip_DESC
  bio_ASC
  bio_DESC
  imageURL_ASC
  imageURL_DESC
  startDate_ASC
  startDate_DESC
  currentEmployee_ASC
  currentEmployee_DESC
  lessonSinglePrice_ASC
  lessonSinglePrice_DESC
  lessonDoublePrice_ASC
  lessonDoublePrice_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EmployeePreviousValues {
  id: ID!
  email: String!
  password: String!
  phone: String!
  firstName: String!
  lastName: String!
  gender: Gender!
  address: String!
  city: String!
  state: String!
  zip: Int!
  bio: String!
  role: [Role!]!
  imageURL: String!
  startDate: DateTime!
  currentEmployee: Boolean!
  lessonSinglePrice: Int
  lessonDoublePrice: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EmployeeSubscriptionPayload {
  mutation: MutationType!
  node: Employee
  updatedFields: [String!]
  previousValues: EmployeePreviousValues
}

input EmployeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployeeWhereInput
  AND: [EmployeeSubscriptionWhereInput!]
  OR: [EmployeeSubscriptionWhereInput!]
  NOT: [EmployeeSubscriptionWhereInput!]
}

input EmployeeUpdateInput {
  email: String
  password: String
  phone: String
  firstName: String
  lastName: String
  gender: Gender
  address: String
  city: String
  state: String
  zip: Int
  bio: String
  role: EmployeeUpdateroleInput
  imageURL: String
  startDate: DateTime
  currentEmployee: Boolean
  clients: StudentUpdateManyInput
  classes: ClassUpdateManyWithoutInstructorInput
  lessons: LessonUpdateManyWithoutInstructorInput
  lessonSinglePrice: Int
  lessonDoublePrice: Int
}

input EmployeeUpdateManyMutationInput {
  email: String
  password: String
  phone: String
  firstName: String
  lastName: String
  gender: Gender
  address: String
  city: String
  state: String
  zip: Int
  bio: String
  role: EmployeeUpdateroleInput
  imageURL: String
  startDate: DateTime
  currentEmployee: Boolean
  lessonSinglePrice: Int
  lessonDoublePrice: Int
}

input EmployeeUpdateOneRequiredWithoutClassesInput {
  create: EmployeeCreateWithoutClassesInput
  update: EmployeeUpdateWithoutClassesDataInput
  upsert: EmployeeUpsertWithoutClassesInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateOneRequiredWithoutLessonsInput {
  create: EmployeeCreateWithoutLessonsInput
  update: EmployeeUpdateWithoutLessonsDataInput
  upsert: EmployeeUpsertWithoutLessonsInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateroleInput {
  set: [Role!]
}

input EmployeeUpdateWithoutClassesDataInput {
  email: String
  password: String
  phone: String
  firstName: String
  lastName: String
  gender: Gender
  address: String
  city: String
  state: String
  zip: Int
  bio: String
  role: EmployeeUpdateroleInput
  imageURL: String
  startDate: DateTime
  currentEmployee: Boolean
  clients: StudentUpdateManyInput
  lessons: LessonUpdateManyWithoutInstructorInput
  lessonSinglePrice: Int
  lessonDoublePrice: Int
}

input EmployeeUpdateWithoutLessonsDataInput {
  email: String
  password: String
  phone: String
  firstName: String
  lastName: String
  gender: Gender
  address: String
  city: String
  state: String
  zip: Int
  bio: String
  role: EmployeeUpdateroleInput
  imageURL: String
  startDate: DateTime
  currentEmployee: Boolean
  clients: StudentUpdateManyInput
  classes: ClassUpdateManyWithoutInstructorInput
  lessonSinglePrice: Int
  lessonDoublePrice: Int
}

input EmployeeUpsertWithoutClassesInput {
  update: EmployeeUpdateWithoutClassesDataInput!
  create: EmployeeCreateWithoutClassesInput!
}

input EmployeeUpsertWithoutLessonsInput {
  update: EmployeeUpdateWithoutLessonsDataInput!
  create: EmployeeCreateWithoutLessonsInput!
}

input EmployeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zip: Int
  zip_not: Int
  zip_in: [Int!]
  zip_not_in: [Int!]
  zip_lt: Int
  zip_lte: Int
  zip_gt: Int
  zip_gte: Int
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  imageURL: String
  imageURL_not: String
  imageURL_in: [String!]
  imageURL_not_in: [String!]
  imageURL_lt: String
  imageURL_lte: String
  imageURL_gt: String
  imageURL_gte: String
  imageURL_contains: String
  imageURL_not_contains: String
  imageURL_starts_with: String
  imageURL_not_starts_with: String
  imageURL_ends_with: String
  imageURL_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  currentEmployee: Boolean
  currentEmployee_not: Boolean
  clients_every: StudentWhereInput
  clients_some: StudentWhereInput
  clients_none: StudentWhereInput
  classes_every: ClassWhereInput
  classes_some: ClassWhereInput
  classes_none: ClassWhereInput
  lessons_every: LessonWhereInput
  lessons_some: LessonWhereInput
  lessons_none: LessonWhereInput
  lessonSinglePrice: Int
  lessonSinglePrice_not: Int
  lessonSinglePrice_in: [Int!]
  lessonSinglePrice_not_in: [Int!]
  lessonSinglePrice_lt: Int
  lessonSinglePrice_lte: Int
  lessonSinglePrice_gt: Int
  lessonSinglePrice_gte: Int
  lessonDoublePrice: Int
  lessonDoublePrice_not: Int
  lessonDoublePrice_in: [Int!]
  lessonDoublePrice_not_in: [Int!]
  lessonDoublePrice_lt: Int
  lessonDoublePrice_lte: Int
  lessonDoublePrice_gt: Int
  lessonDoublePrice_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
}

input EmployeeWhereUniqueInput {
  id: ID
  email: String
  phone: String
}

enum Gender {
  MALE
  FEMALE
}

type Lesson {
  id: ID!
  name: String!
  description: String!
  instructor: Employee!
  client(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
  duration: Int!
  type: LessonType!
  day: Day!
  time: DateTime!
  open: Boolean!
}

type LessonConnection {
  pageInfo: PageInfo!
  edges: [LessonEdge]!
  aggregate: AggregateLesson!
}

input LessonCreateInput {
  id: ID
  name: String!
  description: String!
  instructor: EmployeeCreateOneWithoutLessonsInput!
  client: StudentCreateManyWithoutLessonsInput
  duration: Int!
  type: LessonType!
  day: Day!
  time: DateTime!
  open: Boolean!
}

input LessonCreateManyWithoutClientInput {
  create: [LessonCreateWithoutClientInput!]
  connect: [LessonWhereUniqueInput!]
}

input LessonCreateManyWithoutInstructorInput {
  create: [LessonCreateWithoutInstructorInput!]
  connect: [LessonWhereUniqueInput!]
}

input LessonCreateWithoutClientInput {
  id: ID
  name: String!
  description: String!
  instructor: EmployeeCreateOneWithoutLessonsInput!
  duration: Int!
  type: LessonType!
  day: Day!
  time: DateTime!
  open: Boolean!
}

input LessonCreateWithoutInstructorInput {
  id: ID
  name: String!
  description: String!
  client: StudentCreateManyWithoutLessonsInput
  duration: Int!
  type: LessonType!
  day: Day!
  time: DateTime!
  open: Boolean!
}

type LessonEdge {
  node: Lesson!
  cursor: String!
}

enum LessonOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  duration_ASC
  duration_DESC
  type_ASC
  type_DESC
  day_ASC
  day_DESC
  time_ASC
  time_DESC
  open_ASC
  open_DESC
}

type LessonPreviousValues {
  id: ID!
  name: String!
  description: String!
  duration: Int!
  type: LessonType!
  day: Day!
  time: DateTime!
  open: Boolean!
}

input LessonScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  type: LessonType
  type_not: LessonType
  type_in: [LessonType!]
  type_not_in: [LessonType!]
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  open: Boolean
  open_not: Boolean
  AND: [LessonScalarWhereInput!]
  OR: [LessonScalarWhereInput!]
  NOT: [LessonScalarWhereInput!]
}

type LessonSubscriptionPayload {
  mutation: MutationType!
  node: Lesson
  updatedFields: [String!]
  previousValues: LessonPreviousValues
}

input LessonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LessonWhereInput
  AND: [LessonSubscriptionWhereInput!]
  OR: [LessonSubscriptionWhereInput!]
  NOT: [LessonSubscriptionWhereInput!]
}

enum LessonType {
  ONE
  TWO
}

input LessonUpdateInput {
  name: String
  description: String
  instructor: EmployeeUpdateOneRequiredWithoutLessonsInput
  client: StudentUpdateManyWithoutLessonsInput
  duration: Int
  type: LessonType
  day: Day
  time: DateTime
  open: Boolean
}

input LessonUpdateManyDataInput {
  name: String
  description: String
  duration: Int
  type: LessonType
  day: Day
  time: DateTime
  open: Boolean
}

input LessonUpdateManyMutationInput {
  name: String
  description: String
  duration: Int
  type: LessonType
  day: Day
  time: DateTime
  open: Boolean
}

input LessonUpdateManyWithoutClientInput {
  create: [LessonCreateWithoutClientInput!]
  delete: [LessonWhereUniqueInput!]
  connect: [LessonWhereUniqueInput!]
  set: [LessonWhereUniqueInput!]
  disconnect: [LessonWhereUniqueInput!]
  update: [LessonUpdateWithWhereUniqueWithoutClientInput!]
  upsert: [LessonUpsertWithWhereUniqueWithoutClientInput!]
  deleteMany: [LessonScalarWhereInput!]
  updateMany: [LessonUpdateManyWithWhereNestedInput!]
}

input LessonUpdateManyWithoutInstructorInput {
  create: [LessonCreateWithoutInstructorInput!]
  delete: [LessonWhereUniqueInput!]
  connect: [LessonWhereUniqueInput!]
  set: [LessonWhereUniqueInput!]
  disconnect: [LessonWhereUniqueInput!]
  update: [LessonUpdateWithWhereUniqueWithoutInstructorInput!]
  upsert: [LessonUpsertWithWhereUniqueWithoutInstructorInput!]
  deleteMany: [LessonScalarWhereInput!]
  updateMany: [LessonUpdateManyWithWhereNestedInput!]
}

input LessonUpdateManyWithWhereNestedInput {
  where: LessonScalarWhereInput!
  data: LessonUpdateManyDataInput!
}

input LessonUpdateWithoutClientDataInput {
  name: String
  description: String
  instructor: EmployeeUpdateOneRequiredWithoutLessonsInput
  duration: Int
  type: LessonType
  day: Day
  time: DateTime
  open: Boolean
}

input LessonUpdateWithoutInstructorDataInput {
  name: String
  description: String
  client: StudentUpdateManyWithoutLessonsInput
  duration: Int
  type: LessonType
  day: Day
  time: DateTime
  open: Boolean
}

input LessonUpdateWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput!
  data: LessonUpdateWithoutClientDataInput!
}

input LessonUpdateWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput!
  data: LessonUpdateWithoutInstructorDataInput!
}

input LessonUpsertWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput!
  update: LessonUpdateWithoutClientDataInput!
  create: LessonCreateWithoutClientInput!
}

input LessonUpsertWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput!
  update: LessonUpdateWithoutInstructorDataInput!
  create: LessonCreateWithoutInstructorInput!
}

input LessonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  instructor: EmployeeWhereInput
  client_every: StudentWhereInput
  client_some: StudentWhereInput
  client_none: StudentWhereInput
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  type: LessonType
  type_not: LessonType
  type_in: [LessonType!]
  type_not_in: [LessonType!]
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  open: Boolean
  open_not: Boolean
  AND: [LessonWhereInput!]
  OR: [LessonWhereInput!]
  NOT: [LessonWhereInput!]
}

input LessonWhereUniqueInput {
  id: ID
}

scalar Long

type MedicalCondition {
  id: ID!
  description: String!
  student: Student
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MedicalConditionConnection {
  pageInfo: PageInfo!
  edges: [MedicalConditionEdge]!
  aggregate: AggregateMedicalCondition!
}

input MedicalConditionCreateInput {
  id: ID
  description: String!
  student: StudentCreateOneWithoutMedicalInput
}

input MedicalConditionCreateManyWithoutStudentInput {
  create: [MedicalConditionCreateWithoutStudentInput!]
  connect: [MedicalConditionWhereUniqueInput!]
}

input MedicalConditionCreateWithoutStudentInput {
  id: ID
  description: String!
}

type MedicalConditionEdge {
  node: MedicalCondition!
  cursor: String!
}

enum MedicalConditionOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MedicalConditionPreviousValues {
  id: ID!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input MedicalConditionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MedicalConditionScalarWhereInput!]
  OR: [MedicalConditionScalarWhereInput!]
  NOT: [MedicalConditionScalarWhereInput!]
}

type MedicalConditionSubscriptionPayload {
  mutation: MutationType!
  node: MedicalCondition
  updatedFields: [String!]
  previousValues: MedicalConditionPreviousValues
}

input MedicalConditionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MedicalConditionWhereInput
  AND: [MedicalConditionSubscriptionWhereInput!]
  OR: [MedicalConditionSubscriptionWhereInput!]
  NOT: [MedicalConditionSubscriptionWhereInput!]
}

input MedicalConditionUpdateInput {
  description: String
  student: StudentUpdateOneWithoutMedicalInput
}

input MedicalConditionUpdateManyDataInput {
  description: String
}

input MedicalConditionUpdateManyMutationInput {
  description: String
}

input MedicalConditionUpdateManyWithoutStudentInput {
  create: [MedicalConditionCreateWithoutStudentInput!]
  delete: [MedicalConditionWhereUniqueInput!]
  connect: [MedicalConditionWhereUniqueInput!]
  set: [MedicalConditionWhereUniqueInput!]
  disconnect: [MedicalConditionWhereUniqueInput!]
  update: [MedicalConditionUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [MedicalConditionUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [MedicalConditionScalarWhereInput!]
  updateMany: [MedicalConditionUpdateManyWithWhereNestedInput!]
}

input MedicalConditionUpdateManyWithWhereNestedInput {
  where: MedicalConditionScalarWhereInput!
  data: MedicalConditionUpdateManyDataInput!
}

input MedicalConditionUpdateWithoutStudentDataInput {
  description: String
}

input MedicalConditionUpdateWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput!
  data: MedicalConditionUpdateWithoutStudentDataInput!
}

input MedicalConditionUpsertWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput!
  update: MedicalConditionUpdateWithoutStudentDataInput!
  create: MedicalConditionCreateWithoutStudentInput!
}

input MedicalConditionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  student: StudentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MedicalConditionWhereInput!]
  OR: [MedicalConditionWhereInput!]
  NOT: [MedicalConditionWhereInput!]
}

input MedicalConditionWhereUniqueInput {
  id: ID
}

type Mutation {
  createAccountAdmin(data: AccountAdminCreateInput!): AccountAdmin!
  updateAccountAdmin(data: AccountAdminUpdateInput!, where: AccountAdminWhereUniqueInput!): AccountAdmin
  updateManyAccountAdmins(data: AccountAdminUpdateManyMutationInput!, where: AccountAdminWhereInput): BatchPayload!
  upsertAccountAdmin(where: AccountAdminWhereUniqueInput!, create: AccountAdminCreateInput!, update: AccountAdminUpdateInput!): AccountAdmin!
  deleteAccountAdmin(where: AccountAdminWhereUniqueInput!): AccountAdmin
  deleteManyAccountAdmins(where: AccountAdminWhereInput): BatchPayload!
  createAgeGroup(data: AgeGroupCreateInput!): AgeGroup!
  updateAgeGroup(data: AgeGroupUpdateInput!, where: AgeGroupWhereUniqueInput!): AgeGroup
  updateManyAgeGroups(data: AgeGroupUpdateManyMutationInput!, where: AgeGroupWhereInput): BatchPayload!
  upsertAgeGroup(where: AgeGroupWhereUniqueInput!, create: AgeGroupCreateInput!, update: AgeGroupUpdateInput!): AgeGroup!
  deleteAgeGroup(where: AgeGroupWhereUniqueInput!): AgeGroup
  deleteManyAgeGroups(where: AgeGroupWhereInput): BatchPayload!
  createClass(data: ClassCreateInput!): Class!
  updateClass(data: ClassUpdateInput!, where: ClassWhereUniqueInput!): Class
  updateManyClasses(data: ClassUpdateManyMutationInput!, where: ClassWhereInput): BatchPayload!
  upsertClass(where: ClassWhereUniqueInput!, create: ClassCreateInput!, update: ClassUpdateInput!): Class!
  deleteClass(where: ClassWhereUniqueInput!): Class
  deleteManyClasses(where: ClassWhereInput): BatchPayload!
  createEmployee(data: EmployeeCreateInput!): Employee!
  updateEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateManyEmployees(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): BatchPayload!
  upsertEmployee(where: EmployeeWhereUniqueInput!, create: EmployeeCreateInput!, update: EmployeeUpdateInput!): Employee!
  deleteEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteManyEmployees(where: EmployeeWhereInput): BatchPayload!
  createLesson(data: LessonCreateInput!): Lesson!
  updateLesson(data: LessonUpdateInput!, where: LessonWhereUniqueInput!): Lesson
  updateManyLessons(data: LessonUpdateManyMutationInput!, where: LessonWhereInput): BatchPayload!
  upsertLesson(where: LessonWhereUniqueInput!, create: LessonCreateInput!, update: LessonUpdateInput!): Lesson!
  deleteLesson(where: LessonWhereUniqueInput!): Lesson
  deleteManyLessons(where: LessonWhereInput): BatchPayload!
  createMedicalCondition(data: MedicalConditionCreateInput!): MedicalCondition!
  updateMedicalCondition(data: MedicalConditionUpdateInput!, where: MedicalConditionWhereUniqueInput!): MedicalCondition
  updateManyMedicalConditions(data: MedicalConditionUpdateManyMutationInput!, where: MedicalConditionWhereInput): BatchPayload!
  upsertMedicalCondition(where: MedicalConditionWhereUniqueInput!, create: MedicalConditionCreateInput!, update: MedicalConditionUpdateInput!): MedicalCondition!
  deleteMedicalCondition(where: MedicalConditionWhereUniqueInput!): MedicalCondition
  deleteManyMedicalConditions(where: MedicalConditionWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  accountAdmin(where: AccountAdminWhereUniqueInput!): AccountAdmin
  accountAdmins(where: AccountAdminWhereInput, orderBy: AccountAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AccountAdmin]!
  accountAdminsConnection(where: AccountAdminWhereInput, orderBy: AccountAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountAdminConnection!
  ageGroup(where: AgeGroupWhereUniqueInput!): AgeGroup
  ageGroups(where: AgeGroupWhereInput, orderBy: AgeGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AgeGroup]!
  ageGroupsConnection(where: AgeGroupWhereInput, orderBy: AgeGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AgeGroupConnection!
  class(where: ClassWhereUniqueInput!): Class
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class]!
  classesConnection(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassConnection!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employee]!
  employeesConnection(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployeeConnection!
  lesson(where: LessonWhereUniqueInput!): Lesson
  lessons(where: LessonWhereInput, orderBy: LessonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lesson]!
  lessonsConnection(where: LessonWhereInput, orderBy: LessonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LessonConnection!
  medicalCondition(where: MedicalConditionWhereUniqueInput!): MedicalCondition
  medicalConditions(where: MedicalConditionWhereInput, orderBy: MedicalConditionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MedicalCondition]!
  medicalConditionsConnection(where: MedicalConditionWhereInput, orderBy: MedicalConditionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MedicalConditionConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  node(id: ID!): Node
}

enum Role {
  ADMIN
  INSTRUCTOR
  FRONT_DESK
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

type Student {
  id: ID!
  firstName: String!
  lastName: String!
  birthday: String!
  skill: SkillLevel!
  ageGroup: AgeGroup!
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class!]
  lessons(where: LessonWhereInput, orderBy: LessonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lesson!]
  gender: Gender!
  medical(where: MedicalConditionWhereInput, orderBy: MedicalConditionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MedicalCondition!]
  admin: AccountAdmin
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  id: ID
  firstName: String!
  lastName: String!
  birthday: String!
  skill: SkillLevel!
  ageGroup: AgeGroupCreateOneInput!
  classes: ClassCreateManyWithoutStudentsInput
  lessons: LessonCreateManyWithoutClientInput
  gender: Gender!
  medical: MedicalConditionCreateManyWithoutStudentInput
  admin: AccountAdminCreateOneWithoutStudentsInput
}

input StudentCreateManyInput {
  create: [StudentCreateInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateManyWithoutAdminInput {
  create: [StudentCreateWithoutAdminInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateManyWithoutClassesInput {
  create: [StudentCreateWithoutClassesInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateManyWithoutLessonsInput {
  create: [StudentCreateWithoutLessonsInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateOneWithoutMedicalInput {
  create: StudentCreateWithoutMedicalInput
  connect: StudentWhereUniqueInput
}

input StudentCreateWithoutAdminInput {
  id: ID
  firstName: String!
  lastName: String!
  birthday: String!
  skill: SkillLevel!
  ageGroup: AgeGroupCreateOneInput!
  classes: ClassCreateManyWithoutStudentsInput
  lessons: LessonCreateManyWithoutClientInput
  gender: Gender!
  medical: MedicalConditionCreateManyWithoutStudentInput
}

input StudentCreateWithoutClassesInput {
  id: ID
  firstName: String!
  lastName: String!
  birthday: String!
  skill: SkillLevel!
  ageGroup: AgeGroupCreateOneInput!
  lessons: LessonCreateManyWithoutClientInput
  gender: Gender!
  medical: MedicalConditionCreateManyWithoutStudentInput
  admin: AccountAdminCreateOneWithoutStudentsInput
}

input StudentCreateWithoutLessonsInput {
  id: ID
  firstName: String!
  lastName: String!
  birthday: String!
  skill: SkillLevel!
  ageGroup: AgeGroupCreateOneInput!
  classes: ClassCreateManyWithoutStudentsInput
  gender: Gender!
  medical: MedicalConditionCreateManyWithoutStudentInput
  admin: AccountAdminCreateOneWithoutStudentsInput
}

input StudentCreateWithoutMedicalInput {
  id: ID
  firstName: String!
  lastName: String!
  birthday: String!
  skill: SkillLevel!
  ageGroup: AgeGroupCreateOneInput!
  classes: ClassCreateManyWithoutStudentsInput
  lessons: LessonCreateManyWithoutClientInput
  gender: Gender!
  admin: AccountAdminCreateOneWithoutStudentsInput
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  birthday_ASC
  birthday_DESC
  skill_ASC
  skill_DESC
  gender_ASC
  gender_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StudentPreviousValues {
  id: ID!
  firstName: String!
  lastName: String!
  birthday: String!
  skill: SkillLevel!
  gender: Gender!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input StudentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  birthday: String
  birthday_not: String
  birthday_in: [String!]
  birthday_not_in: [String!]
  birthday_lt: String
  birthday_lte: String
  birthday_gt: String
  birthday_gte: String
  birthday_contains: String
  birthday_not_contains: String
  birthday_starts_with: String
  birthday_not_starts_with: String
  birthday_ends_with: String
  birthday_not_ends_with: String
  skill: SkillLevel
  skill_not: SkillLevel
  skill_in: [SkillLevel!]
  skill_not_in: [SkillLevel!]
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StudentScalarWhereInput!]
  OR: [StudentScalarWhereInput!]
  NOT: [StudentScalarWhereInput!]
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateDataInput {
  firstName: String
  lastName: String
  birthday: String
  skill: SkillLevel
  ageGroup: AgeGroupUpdateOneRequiredInput
  classes: ClassUpdateManyWithoutStudentsInput
  lessons: LessonUpdateManyWithoutClientInput
  gender: Gender
  medical: MedicalConditionUpdateManyWithoutStudentInput
  admin: AccountAdminUpdateOneWithoutStudentsInput
}

input StudentUpdateInput {
  firstName: String
  lastName: String
  birthday: String
  skill: SkillLevel
  ageGroup: AgeGroupUpdateOneRequiredInput
  classes: ClassUpdateManyWithoutStudentsInput
  lessons: LessonUpdateManyWithoutClientInput
  gender: Gender
  medical: MedicalConditionUpdateManyWithoutStudentInput
  admin: AccountAdminUpdateOneWithoutStudentsInput
}

input StudentUpdateManyDataInput {
  firstName: String
  lastName: String
  birthday: String
  skill: SkillLevel
  gender: Gender
}

input StudentUpdateManyInput {
  create: [StudentCreateInput!]
  update: [StudentUpdateWithWhereUniqueNestedInput!]
  upsert: [StudentUpsertWithWhereUniqueNestedInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyMutationInput {
  firstName: String
  lastName: String
  birthday: String
  skill: SkillLevel
  gender: Gender
}

input StudentUpdateManyWithoutAdminInput {
  create: [StudentCreateWithoutAdminInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutAdminInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutAdminInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyWithoutClassesInput {
  create: [StudentCreateWithoutClassesInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutClassesInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutClassesInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyWithoutLessonsInput {
  create: [StudentCreateWithoutLessonsInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutLessonsInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutLessonsInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput!
  data: StudentUpdateManyDataInput!
}

input StudentUpdateOneWithoutMedicalInput {
  create: StudentCreateWithoutMedicalInput
  update: StudentUpdateWithoutMedicalDataInput
  upsert: StudentUpsertWithoutMedicalInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateWithoutAdminDataInput {
  firstName: String
  lastName: String
  birthday: String
  skill: SkillLevel
  ageGroup: AgeGroupUpdateOneRequiredInput
  classes: ClassUpdateManyWithoutStudentsInput
  lessons: LessonUpdateManyWithoutClientInput
  gender: Gender
  medical: MedicalConditionUpdateManyWithoutStudentInput
}

input StudentUpdateWithoutClassesDataInput {
  firstName: String
  lastName: String
  birthday: String
  skill: SkillLevel
  ageGroup: AgeGroupUpdateOneRequiredInput
  lessons: LessonUpdateManyWithoutClientInput
  gender: Gender
  medical: MedicalConditionUpdateManyWithoutStudentInput
  admin: AccountAdminUpdateOneWithoutStudentsInput
}

input StudentUpdateWithoutLessonsDataInput {
  firstName: String
  lastName: String
  birthday: String
  skill: SkillLevel
  ageGroup: AgeGroupUpdateOneRequiredInput
  classes: ClassUpdateManyWithoutStudentsInput
  gender: Gender
  medical: MedicalConditionUpdateManyWithoutStudentInput
  admin: AccountAdminUpdateOneWithoutStudentsInput
}

input StudentUpdateWithoutMedicalDataInput {
  firstName: String
  lastName: String
  birthday: String
  skill: SkillLevel
  ageGroup: AgeGroupUpdateOneRequiredInput
  classes: ClassUpdateManyWithoutStudentsInput
  lessons: LessonUpdateManyWithoutClientInput
  gender: Gender
  admin: AccountAdminUpdateOneWithoutStudentsInput
}

input StudentUpdateWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateDataInput!
}

input StudentUpdateWithWhereUniqueWithoutAdminInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateWithoutAdminDataInput!
}

input StudentUpdateWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateWithoutClassesDataInput!
}

input StudentUpdateWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateWithoutLessonsDataInput!
}

input StudentUpsertWithoutMedicalInput {
  update: StudentUpdateWithoutMedicalDataInput!
  create: StudentCreateWithoutMedicalInput!
}

input StudentUpsertWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateDataInput!
  create: StudentCreateInput!
}

input StudentUpsertWithWhereUniqueWithoutAdminInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateWithoutAdminDataInput!
  create: StudentCreateWithoutAdminInput!
}

input StudentUpsertWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateWithoutClassesDataInput!
  create: StudentCreateWithoutClassesInput!
}

input StudentUpsertWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateWithoutLessonsDataInput!
  create: StudentCreateWithoutLessonsInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  birthday: String
  birthday_not: String
  birthday_in: [String!]
  birthday_not_in: [String!]
  birthday_lt: String
  birthday_lte: String
  birthday_gt: String
  birthday_gte: String
  birthday_contains: String
  birthday_not_contains: String
  birthday_starts_with: String
  birthday_not_starts_with: String
  birthday_ends_with: String
  birthday_not_ends_with: String
  skill: SkillLevel
  skill_not: SkillLevel
  skill_in: [SkillLevel!]
  skill_not_in: [SkillLevel!]
  ageGroup: AgeGroupWhereInput
  classes_every: ClassWhereInput
  classes_some: ClassWhereInput
  classes_none: ClassWhereInput
  lessons_every: LessonWhereInput
  lessons_some: LessonWhereInput
  lessons_none: LessonWhereInput
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  medical_every: MedicalConditionWhereInput
  medical_some: MedicalConditionWhereInput
  medical_none: MedicalConditionWhereInput
  admin: AccountAdminWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
}

type Subscription {
  accountAdmin(where: AccountAdminSubscriptionWhereInput): AccountAdminSubscriptionPayload
  ageGroup(where: AgeGroupSubscriptionWhereInput): AgeGroupSubscriptionPayload
  class(where: ClassSubscriptionWhereInput): ClassSubscriptionPayload
  employee(where: EmployeeSubscriptionWhereInput): EmployeeSubscriptionPayload
  lesson(where: LessonSubscriptionWhereInput): LessonSubscriptionPayload
  medicalCondition(where: MedicalConditionSubscriptionWhereInput): MedicalConditionSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
}
`
      }
    