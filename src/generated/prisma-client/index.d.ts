// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  ageGroup: (where?: AgeGroupWhereInput) => Promise<boolean>;
  class: (where?: ClassWhereInput) => Promise<boolean>;
  client: (where?: ClientWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  lesson: (where?: LessonWhereInput) => Promise<boolean>;
  medicalCondition: (where?: MedicalConditionWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  ageGroup: (where: AgeGroupWhereUniqueInput) => AgeGroupPromise;
  ageGroups: (args?: {
    where?: AgeGroupWhereInput;
    orderBy?: AgeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AgeGroup>;
  ageGroupsConnection: (args?: {
    where?: AgeGroupWhereInput;
    orderBy?: AgeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AgeGroupConnectionPromise;
  class: (where: ClassWhereUniqueInput) => ClassPromise;
  classes: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Class>;
  classesConnection: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassConnectionPromise;
  client: (where: ClientWhereUniqueInput) => ClientPromise;
  clients: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Client>;
  clientsConnection: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClientConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  employees: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Employee>;
  employeesConnection: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeeConnectionPromise;
  lesson: (where: LessonWhereUniqueInput) => LessonPromise;
  lessons: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lesson>;
  lessonsConnection: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LessonConnectionPromise;
  medicalCondition: (
    where: MedicalConditionWhereUniqueInput
  ) => MedicalConditionPromise;
  medicalConditions: (args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MedicalCondition>;
  medicalConditionsConnection: (args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MedicalConditionConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentPromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAgeGroup: (data: AgeGroupCreateInput) => AgeGroupPromise;
  updateAgeGroup: (args: {
    data: AgeGroupUpdateInput;
    where: AgeGroupWhereUniqueInput;
  }) => AgeGroupPromise;
  updateManyAgeGroups: (args: {
    data: AgeGroupUpdateManyMutationInput;
    where?: AgeGroupWhereInput;
  }) => BatchPayloadPromise;
  upsertAgeGroup: (args: {
    where: AgeGroupWhereUniqueInput;
    create: AgeGroupCreateInput;
    update: AgeGroupUpdateInput;
  }) => AgeGroupPromise;
  deleteAgeGroup: (where: AgeGroupWhereUniqueInput) => AgeGroupPromise;
  deleteManyAgeGroups: (where?: AgeGroupWhereInput) => BatchPayloadPromise;
  createClass: (data: ClassCreateInput) => ClassPromise;
  updateClass: (args: {
    data: ClassUpdateInput;
    where: ClassWhereUniqueInput;
  }) => ClassPromise;
  updateManyClasses: (args: {
    data: ClassUpdateManyMutationInput;
    where?: ClassWhereInput;
  }) => BatchPayloadPromise;
  upsertClass: (args: {
    where: ClassWhereUniqueInput;
    create: ClassCreateInput;
    update: ClassUpdateInput;
  }) => ClassPromise;
  deleteClass: (where: ClassWhereUniqueInput) => ClassPromise;
  deleteManyClasses: (where?: ClassWhereInput) => BatchPayloadPromise;
  createClient: (data: ClientCreateInput) => ClientPromise;
  updateClient: (args: {
    data: ClientUpdateInput;
    where: ClientWhereUniqueInput;
  }) => ClientPromise;
  updateManyClients: (args: {
    data: ClientUpdateManyMutationInput;
    where?: ClientWhereInput;
  }) => BatchPayloadPromise;
  upsertClient: (args: {
    where: ClientWhereUniqueInput;
    create: ClientCreateInput;
    update: ClientUpdateInput;
  }) => ClientPromise;
  deleteClient: (where: ClientWhereUniqueInput) => ClientPromise;
  deleteManyClients: (where?: ClientWhereInput) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (args: {
    data: EmployeeUpdateInput;
    where: EmployeeWhereUniqueInput;
  }) => EmployeePromise;
  updateManyEmployees: (args: {
    data: EmployeeUpdateManyMutationInput;
    where?: EmployeeWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployee: (args: {
    where: EmployeeWhereUniqueInput;
    create: EmployeeCreateInput;
    update: EmployeeUpdateInput;
  }) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createLesson: (data: LessonCreateInput) => LessonPromise;
  updateLesson: (args: {
    data: LessonUpdateInput;
    where: LessonWhereUniqueInput;
  }) => LessonPromise;
  updateManyLessons: (args: {
    data: LessonUpdateManyMutationInput;
    where?: LessonWhereInput;
  }) => BatchPayloadPromise;
  upsertLesson: (args: {
    where: LessonWhereUniqueInput;
    create: LessonCreateInput;
    update: LessonUpdateInput;
  }) => LessonPromise;
  deleteLesson: (where: LessonWhereUniqueInput) => LessonPromise;
  deleteManyLessons: (where?: LessonWhereInput) => BatchPayloadPromise;
  createMedicalCondition: (
    data: MedicalConditionCreateInput
  ) => MedicalConditionPromise;
  updateMedicalCondition: (args: {
    data: MedicalConditionUpdateInput;
    where: MedicalConditionWhereUniqueInput;
  }) => MedicalConditionPromise;
  updateManyMedicalConditions: (args: {
    data: MedicalConditionUpdateManyMutationInput;
    where?: MedicalConditionWhereInput;
  }) => BatchPayloadPromise;
  upsertMedicalCondition: (args: {
    where: MedicalConditionWhereUniqueInput;
    create: MedicalConditionCreateInput;
    update: MedicalConditionUpdateInput;
  }) => MedicalConditionPromise;
  deleteMedicalCondition: (
    where: MedicalConditionWhereUniqueInput
  ) => MedicalConditionPromise;
  deleteManyMedicalConditions: (
    where?: MedicalConditionWhereInput
  ) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  ageGroup: (
    where?: AgeGroupSubscriptionWhereInput
  ) => AgeGroupSubscriptionPayloadSubscription;
  class: (
    where?: ClassSubscriptionWhereInput
  ) => ClassSubscriptionPayloadSubscription;
  client: (
    where?: ClientSubscriptionWhereInput
  ) => ClientSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  lesson: (
    where?: LessonSubscriptionWhereInput
  ) => LessonSubscriptionPayloadSubscription;
  medicalCondition: (
    where?: MedicalConditionSubscriptionWhereInput
  ) => MedicalConditionSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AgeGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "minAge_ASC"
  | "minAge_DESC"
  | "maxAge_ASC"
  | "maxAge_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SkillLevel = "BEGINNER" | "INTERMEDIATE" | "ADVANCED";

export type Day =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY";

export type Gender = "MALE" | "FEMALE" | "OTHER";

export type Role = "ADMIN" | "INSTRUCTOR" | "FRONT_DESK";

export type LessonType = "SINGLE" | "PAIR";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "skill_ASC"
  | "skill_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClassOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "level_ASC"
  | "level_DESC"
  | "capacity_ASC"
  | "capacity_DESC"
  | "price_ASC"
  | "price_DESC"
  | "day_ASC"
  | "day_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "time_ASC"
  | "time_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LessonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "type_ASC"
  | "type_DESC"
  | "day_ASC"
  | "day_DESC"
  | "time_ASC"
  | "time_DESC"
  | "open_ASC"
  | "open_DESC";

export type MedicalConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "stripeId_ASC"
  | "stripeId_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmployeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "imageURL_ASC"
  | "imageURL_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "currentEmployee_ASC"
  | "currentEmployee_DESC"
  | "lessonSinglePrice_ASC"
  | "lessonSinglePrice_DESC"
  | "lessonDoublePrice_ASC"
  | "lessonDoublePrice_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AgeGroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AgeGroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  minAge?: Int;
  minAge_not?: Int;
  minAge_in?: Int[] | Int;
  minAge_not_in?: Int[] | Int;
  minAge_lt?: Int;
  minAge_lte?: Int;
  minAge_gt?: Int;
  minAge_gte?: Int;
  maxAge?: Int;
  maxAge_not?: Int;
  maxAge_in?: Int[] | Int;
  maxAge_not_in?: Int[] | Int;
  maxAge_lt?: Int;
  maxAge_lte?: Int;
  maxAge_gt?: Int;
  maxAge_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AgeGroupWhereInput[] | AgeGroupWhereInput;
  OR?: AgeGroupWhereInput[] | AgeGroupWhereInput;
  NOT?: AgeGroupWhereInput[] | AgeGroupWhereInput;
}

export type ClassWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  birthday?: String;
  birthday_not?: String;
  birthday_in?: String[] | String;
  birthday_not_in?: String[] | String;
  birthday_lt?: String;
  birthday_lte?: String;
  birthday_gt?: String;
  birthday_gte?: String;
  birthday_contains?: String;
  birthday_not_contains?: String;
  birthday_starts_with?: String;
  birthday_not_starts_with?: String;
  birthday_ends_with?: String;
  birthday_not_ends_with?: String;
  skill?: SkillLevel;
  skill_not?: SkillLevel;
  skill_in?: SkillLevel[] | SkillLevel;
  skill_not_in?: SkillLevel[] | SkillLevel;
  ageGroup?: AgeGroupWhereInput;
  classes_every?: ClassWhereInput;
  classes_some?: ClassWhereInput;
  classes_none?: ClassWhereInput;
  lessons_every?: LessonWhereInput;
  lessons_some?: LessonWhereInput;
  lessons_none?: LessonWhereInput;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  medical_every?: MedicalConditionWhereInput;
  medical_some?: MedicalConditionWhereInput;
  medical_none?: MedicalConditionWhereInput;
  admin?: ClientWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: StudentWhereInput[] | StudentWhereInput;
  OR?: StudentWhereInput[] | StudentWhereInput;
  NOT?: StudentWhereInput[] | StudentWhereInput;
}

export interface ClassWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  ageGroup?: AgeGroupWhereInput;
  level?: SkillLevel;
  level_not?: SkillLevel;
  level_in?: SkillLevel[] | SkillLevel;
  level_not_in?: SkillLevel[] | SkillLevel;
  capacity?: Int;
  capacity_not?: Int;
  capacity_in?: Int[] | Int;
  capacity_not_in?: Int[] | Int;
  capacity_lt?: Int;
  capacity_lte?: Int;
  capacity_gt?: Int;
  capacity_gte?: Int;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  instructor?: EmployeeWhereInput;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  students_every?: StudentWhereInput;
  students_some?: StudentWhereInput;
  students_none?: StudentWhereInput;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ClassWhereInput[] | ClassWhereInput;
  OR?: ClassWhereInput[] | ClassWhereInput;
  NOT?: ClassWhereInput[] | ClassWhereInput;
}

export interface EmployeeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  zip?: Int;
  zip_not?: Int;
  zip_in?: Int[] | Int;
  zip_not_in?: Int[] | Int;
  zip_lt?: Int;
  zip_lte?: Int;
  zip_gt?: Int;
  zip_gte?: Int;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  imageURL?: String;
  imageURL_not?: String;
  imageURL_in?: String[] | String;
  imageURL_not_in?: String[] | String;
  imageURL_lt?: String;
  imageURL_lte?: String;
  imageURL_gt?: String;
  imageURL_gte?: String;
  imageURL_contains?: String;
  imageURL_not_contains?: String;
  imageURL_starts_with?: String;
  imageURL_not_starts_with?: String;
  imageURL_ends_with?: String;
  imageURL_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  currentEmployee?: Boolean;
  currentEmployee_not?: Boolean;
  clients_every?: StudentWhereInput;
  clients_some?: StudentWhereInput;
  clients_none?: StudentWhereInput;
  classes_every?: ClassWhereInput;
  classes_some?: ClassWhereInput;
  classes_none?: ClassWhereInput;
  lessons_every?: LessonWhereInput;
  lessons_some?: LessonWhereInput;
  lessons_none?: LessonWhereInput;
  lessonSinglePrice?: Int;
  lessonSinglePrice_not?: Int;
  lessonSinglePrice_in?: Int[] | Int;
  lessonSinglePrice_not_in?: Int[] | Int;
  lessonSinglePrice_lt?: Int;
  lessonSinglePrice_lte?: Int;
  lessonSinglePrice_gt?: Int;
  lessonSinglePrice_gte?: Int;
  lessonDoublePrice?: Int;
  lessonDoublePrice_not?: Int;
  lessonDoublePrice_in?: Int[] | Int;
  lessonDoublePrice_not_in?: Int[] | Int;
  lessonDoublePrice_lt?: Int;
  lessonDoublePrice_lte?: Int;
  lessonDoublePrice_gt?: Int;
  lessonDoublePrice_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: EmployeeWhereInput[] | EmployeeWhereInput;
  OR?: EmployeeWhereInput[] | EmployeeWhereInput;
  NOT?: EmployeeWhereInput[] | EmployeeWhereInput;
}

export interface LessonWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  instructor?: EmployeeWhereInput;
  client_every?: StudentWhereInput;
  client_some?: StudentWhereInput;
  client_none?: StudentWhereInput;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  type?: LessonType;
  type_not?: LessonType;
  type_in?: LessonType[] | LessonType;
  type_not_in?: LessonType[] | LessonType;
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  open?: Boolean;
  open_not?: Boolean;
  AND?: LessonWhereInput[] | LessonWhereInput;
  OR?: LessonWhereInput[] | LessonWhereInput;
  NOT?: LessonWhereInput[] | LessonWhereInput;
}

export interface MedicalConditionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  student?: StudentWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MedicalConditionWhereInput[] | MedicalConditionWhereInput;
  OR?: MedicalConditionWhereInput[] | MedicalConditionWhereInput;
  NOT?: MedicalConditionWhereInput[] | MedicalConditionWhereInput;
}

export interface ClientWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  zip?: Int;
  zip_not?: Int;
  zip_in?: Int[] | Int;
  zip_not_in?: Int[] | Int;
  zip_lt?: Int;
  zip_lte?: Int;
  zip_gt?: Int;
  zip_gte?: Int;
  students_every?: StudentWhereInput;
  students_some?: StudentWhereInput;
  students_none?: StudentWhereInput;
  stripeId?: String;
  stripeId_not?: String;
  stripeId_in?: String[] | String;
  stripeId_not_in?: String[] | String;
  stripeId_lt?: String;
  stripeId_lte?: String;
  stripeId_gt?: String;
  stripeId_gte?: String;
  stripeId_contains?: String;
  stripeId_not_contains?: String;
  stripeId_starts_with?: String;
  stripeId_not_starts_with?: String;
  stripeId_ends_with?: String;
  stripeId_not_ends_with?: String;
  resetToken?: String;
  resetToken_not?: String;
  resetToken_in?: String[] | String;
  resetToken_not_in?: String[] | String;
  resetToken_lt?: String;
  resetToken_lte?: String;
  resetToken_gt?: String;
  resetToken_gte?: String;
  resetToken_contains?: String;
  resetToken_not_contains?: String;
  resetToken_starts_with?: String;
  resetToken_not_starts_with?: String;
  resetToken_ends_with?: String;
  resetToken_not_ends_with?: String;
  resetTokenExpiry?: String;
  resetTokenExpiry_not?: String;
  resetTokenExpiry_in?: String[] | String;
  resetTokenExpiry_not_in?: String[] | String;
  resetTokenExpiry_lt?: String;
  resetTokenExpiry_lte?: String;
  resetTokenExpiry_gt?: String;
  resetTokenExpiry_gte?: String;
  resetTokenExpiry_contains?: String;
  resetTokenExpiry_not_contains?: String;
  resetTokenExpiry_starts_with?: String;
  resetTokenExpiry_not_starts_with?: String;
  resetTokenExpiry_ends_with?: String;
  resetTokenExpiry_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ClientWhereInput[] | ClientWhereInput;
  OR?: ClientWhereInput[] | ClientWhereInput;
  NOT?: ClientWhereInput[] | ClientWhereInput;
}

export type ClientWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  phone?: String;
}>;

export type LessonWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MedicalConditionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type StudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AgeGroupCreateInput {
  id?: ID_Input;
  name: String;
  minAge: Int;
  maxAge?: Int;
}

export interface AgeGroupUpdateInput {
  name?: String;
  minAge?: Int;
  maxAge?: Int;
}

export interface AgeGroupUpdateManyMutationInput {
  name?: String;
  minAge?: Int;
  maxAge?: Int;
}

export interface ClassCreateInput {
  id?: ID_Input;
  name?: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  instructor: EmployeeCreateOneWithoutClassesInput;
  duration: Int;
  students?: StudentCreateManyWithoutClassesInput;
  time: String;
}

export interface AgeGroupCreateOneInput {
  create?: AgeGroupCreateInput;
  connect?: AgeGroupWhereUniqueInput;
}

export interface EmployeeCreateOneWithoutClassesInput {
  create?: EmployeeCreateWithoutClassesInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeCreateWithoutClassesInput {
  id?: ID_Input;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role?: EmployeeCreateroleInput;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentCreateManyInput;
  lessons?: LessonCreateManyWithoutInstructorInput;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
}

export interface EmployeeCreateroleInput {
  set?: Role[] | Role;
}

export interface StudentCreateManyInput {
  create?: StudentCreateInput[] | StudentCreateInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: ClassCreateManyWithoutStudentsInput;
  lessons?: LessonCreateManyWithoutClientInput;
  gender: Gender;
  medical?: MedicalConditionCreateManyWithoutStudentInput;
  admin?: ClientCreateOneWithoutStudentsInput;
}

export interface ClassCreateManyWithoutStudentsInput {
  create?: ClassCreateWithoutStudentsInput[] | ClassCreateWithoutStudentsInput;
  connect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
}

export interface ClassCreateWithoutStudentsInput {
  id?: ID_Input;
  name?: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  instructor: EmployeeCreateOneWithoutClassesInput;
  duration: Int;
  time: String;
}

export interface LessonCreateManyWithoutClientInput {
  create?: LessonCreateWithoutClientInput[] | LessonCreateWithoutClientInput;
  connect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
}

export interface LessonCreateWithoutClientInput {
  id?: ID_Input;
  instructor: EmployeeCreateOneWithoutLessonsInput;
  duration: Int;
  type?: LessonType;
  day: Day;
  time: String;
  open: Boolean;
}

export interface EmployeeCreateOneWithoutLessonsInput {
  create?: EmployeeCreateWithoutLessonsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeCreateWithoutLessonsInput {
  id?: ID_Input;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role?: EmployeeCreateroleInput;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentCreateManyInput;
  classes?: ClassCreateManyWithoutInstructorInput;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
}

export interface ClassCreateManyWithoutInstructorInput {
  create?:
    | ClassCreateWithoutInstructorInput[]
    | ClassCreateWithoutInstructorInput;
  connect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
}

export interface ClassCreateWithoutInstructorInput {
  id?: ID_Input;
  name?: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  students?: StudentCreateManyWithoutClassesInput;
  time: String;
}

export interface StudentCreateManyWithoutClassesInput {
  create?:
    | StudentCreateWithoutClassesInput[]
    | StudentCreateWithoutClassesInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutClassesInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  lessons?: LessonCreateManyWithoutClientInput;
  gender: Gender;
  medical?: MedicalConditionCreateManyWithoutStudentInput;
  admin?: ClientCreateOneWithoutStudentsInput;
}

export interface MedicalConditionCreateManyWithoutStudentInput {
  create?:
    | MedicalConditionCreateWithoutStudentInput[]
    | MedicalConditionCreateWithoutStudentInput;
  connect?:
    | MedicalConditionWhereUniqueInput[]
    | MedicalConditionWhereUniqueInput;
}

export interface MedicalConditionCreateWithoutStudentInput {
  id?: ID_Input;
  description: String;
}

export interface ClientCreateOneWithoutStudentsInput {
  create?: ClientCreateWithoutStudentsInput;
  connect?: ClientWhereUniqueInput;
}

export interface ClientCreateWithoutStudentsInput {
  id?: ID_Input;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface LessonCreateManyWithoutInstructorInput {
  create?:
    | LessonCreateWithoutInstructorInput[]
    | LessonCreateWithoutInstructorInput;
  connect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
}

export interface LessonCreateWithoutInstructorInput {
  id?: ID_Input;
  client?: StudentCreateManyWithoutLessonsInput;
  duration: Int;
  type?: LessonType;
  day: Day;
  time: String;
  open: Boolean;
}

export interface StudentCreateManyWithoutLessonsInput {
  create?:
    | StudentCreateWithoutLessonsInput[]
    | StudentCreateWithoutLessonsInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutLessonsInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: ClassCreateManyWithoutStudentsInput;
  gender: Gender;
  medical?: MedicalConditionCreateManyWithoutStudentInput;
  admin?: ClientCreateOneWithoutStudentsInput;
}

export interface ClassUpdateInput {
  name?: String;
  description?: String;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  instructor?: EmployeeUpdateOneRequiredWithoutClassesInput;
  duration?: Int;
  students?: StudentUpdateManyWithoutClassesInput;
  time?: String;
}

export interface AgeGroupUpdateOneRequiredInput {
  create?: AgeGroupCreateInput;
  update?: AgeGroupUpdateDataInput;
  upsert?: AgeGroupUpsertNestedInput;
  connect?: AgeGroupWhereUniqueInput;
}

export interface AgeGroupUpdateDataInput {
  name?: String;
  minAge?: Int;
  maxAge?: Int;
}

export interface AgeGroupUpsertNestedInput {
  update: AgeGroupUpdateDataInput;
  create: AgeGroupCreateInput;
}

export interface EmployeeUpdateOneRequiredWithoutClassesInput {
  create?: EmployeeCreateWithoutClassesInput;
  update?: EmployeeUpdateWithoutClassesDataInput;
  upsert?: EmployeeUpsertWithoutClassesInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeUpdateWithoutClassesDataInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: EmployeeUpdateroleInput;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentUpdateManyInput;
  lessons?: LessonUpdateManyWithoutInstructorInput;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
}

export interface EmployeeUpdateroleInput {
  set?: Role[] | Role;
}

export interface StudentUpdateManyInput {
  create?: StudentCreateInput[] | StudentCreateInput;
  update?:
    | StudentUpdateWithWhereUniqueNestedInput[]
    | StudentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StudentUpsertWithWhereUniqueNestedInput[]
    | StudentUpsertWithWhereUniqueNestedInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateDataInput;
}

export interface StudentUpdateDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
  admin?: ClientUpdateOneWithoutStudentsInput;
}

export interface ClassUpdateManyWithoutStudentsInput {
  create?: ClassCreateWithoutStudentsInput[] | ClassCreateWithoutStudentsInput;
  delete?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  connect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  set?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  disconnect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  update?:
    | ClassUpdateWithWhereUniqueWithoutStudentsInput[]
    | ClassUpdateWithWhereUniqueWithoutStudentsInput;
  upsert?:
    | ClassUpsertWithWhereUniqueWithoutStudentsInput[]
    | ClassUpsertWithWhereUniqueWithoutStudentsInput;
  deleteMany?: ClassScalarWhereInput[] | ClassScalarWhereInput;
  updateMany?:
    | ClassUpdateManyWithWhereNestedInput[]
    | ClassUpdateManyWithWhereNestedInput;
}

export interface ClassUpdateWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutStudentsDataInput;
}

export interface ClassUpdateWithoutStudentsDataInput {
  name?: String;
  description?: String;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  instructor?: EmployeeUpdateOneRequiredWithoutClassesInput;
  duration?: Int;
  time?: String;
}

export interface ClassUpsertWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutStudentsDataInput;
  create: ClassCreateWithoutStudentsInput;
}

export interface ClassScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  level?: SkillLevel;
  level_not?: SkillLevel;
  level_in?: SkillLevel[] | SkillLevel;
  level_not_in?: SkillLevel[] | SkillLevel;
  capacity?: Int;
  capacity_not?: Int;
  capacity_in?: Int[] | Int;
  capacity_not_in?: Int[] | Int;
  capacity_lt?: Int;
  capacity_lte?: Int;
  capacity_gt?: Int;
  capacity_gte?: Int;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ClassScalarWhereInput[] | ClassScalarWhereInput;
  OR?: ClassScalarWhereInput[] | ClassScalarWhereInput;
  NOT?: ClassScalarWhereInput[] | ClassScalarWhereInput;
}

export interface ClassUpdateManyWithWhereNestedInput {
  where: ClassScalarWhereInput;
  data: ClassUpdateManyDataInput;
}

export interface ClassUpdateManyDataInput {
  name?: String;
  description?: String;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  duration?: Int;
  time?: String;
}

export interface LessonUpdateManyWithoutClientInput {
  create?: LessonCreateWithoutClientInput[] | LessonCreateWithoutClientInput;
  delete?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  connect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  set?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  disconnect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  update?:
    | LessonUpdateWithWhereUniqueWithoutClientInput[]
    | LessonUpdateWithWhereUniqueWithoutClientInput;
  upsert?:
    | LessonUpsertWithWhereUniqueWithoutClientInput[]
    | LessonUpsertWithWhereUniqueWithoutClientInput;
  deleteMany?: LessonScalarWhereInput[] | LessonScalarWhereInput;
  updateMany?:
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput;
}

export interface LessonUpdateWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutClientDataInput;
}

export interface LessonUpdateWithoutClientDataInput {
  instructor?: EmployeeUpdateOneRequiredWithoutLessonsInput;
  duration?: Int;
  type?: LessonType;
  day?: Day;
  time?: String;
  open?: Boolean;
}

export interface EmployeeUpdateOneRequiredWithoutLessonsInput {
  create?: EmployeeCreateWithoutLessonsInput;
  update?: EmployeeUpdateWithoutLessonsDataInput;
  upsert?: EmployeeUpsertWithoutLessonsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeUpdateWithoutLessonsDataInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: EmployeeUpdateroleInput;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentUpdateManyInput;
  classes?: ClassUpdateManyWithoutInstructorInput;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
}

export interface ClassUpdateManyWithoutInstructorInput {
  create?:
    | ClassCreateWithoutInstructorInput[]
    | ClassCreateWithoutInstructorInput;
  delete?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  connect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  set?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  disconnect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  update?:
    | ClassUpdateWithWhereUniqueWithoutInstructorInput[]
    | ClassUpdateWithWhereUniqueWithoutInstructorInput;
  upsert?:
    | ClassUpsertWithWhereUniqueWithoutInstructorInput[]
    | ClassUpsertWithWhereUniqueWithoutInstructorInput;
  deleteMany?: ClassScalarWhereInput[] | ClassScalarWhereInput;
  updateMany?:
    | ClassUpdateManyWithWhereNestedInput[]
    | ClassUpdateManyWithWhereNestedInput;
}

export interface ClassUpdateWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutInstructorDataInput;
}

export interface ClassUpdateWithoutInstructorDataInput {
  name?: String;
  description?: String;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  duration?: Int;
  students?: StudentUpdateManyWithoutClassesInput;
  time?: String;
}

export interface StudentUpdateManyWithoutClassesInput {
  create?:
    | StudentCreateWithoutClassesInput[]
    | StudentCreateWithoutClassesInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutClassesInput[]
    | StudentUpdateWithWhereUniqueWithoutClassesInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutClassesInput[]
    | StudentUpsertWithWhereUniqueWithoutClassesInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutClassesDataInput;
}

export interface StudentUpdateWithoutClassesDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
  admin?: ClientUpdateOneWithoutStudentsInput;
}

export interface MedicalConditionUpdateManyWithoutStudentInput {
  create?:
    | MedicalConditionCreateWithoutStudentInput[]
    | MedicalConditionCreateWithoutStudentInput;
  delete?:
    | MedicalConditionWhereUniqueInput[]
    | MedicalConditionWhereUniqueInput;
  connect?:
    | MedicalConditionWhereUniqueInput[]
    | MedicalConditionWhereUniqueInput;
  set?: MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput;
  disconnect?:
    | MedicalConditionWhereUniqueInput[]
    | MedicalConditionWhereUniqueInput;
  update?:
    | MedicalConditionUpdateWithWhereUniqueWithoutStudentInput[]
    | MedicalConditionUpdateWithWhereUniqueWithoutStudentInput;
  upsert?:
    | MedicalConditionUpsertWithWhereUniqueWithoutStudentInput[]
    | MedicalConditionUpsertWithWhereUniqueWithoutStudentInput;
  deleteMany?:
    | MedicalConditionScalarWhereInput[]
    | MedicalConditionScalarWhereInput;
  updateMany?:
    | MedicalConditionUpdateManyWithWhereNestedInput[]
    | MedicalConditionUpdateManyWithWhereNestedInput;
}

export interface MedicalConditionUpdateWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput;
  data: MedicalConditionUpdateWithoutStudentDataInput;
}

export interface MedicalConditionUpdateWithoutStudentDataInput {
  description?: String;
}

export interface MedicalConditionUpsertWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput;
  update: MedicalConditionUpdateWithoutStudentDataInput;
  create: MedicalConditionCreateWithoutStudentInput;
}

export interface MedicalConditionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput;
  OR?: MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput;
  NOT?: MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput;
}

export interface MedicalConditionUpdateManyWithWhereNestedInput {
  where: MedicalConditionScalarWhereInput;
  data: MedicalConditionUpdateManyDataInput;
}

export interface MedicalConditionUpdateManyDataInput {
  description?: String;
}

export interface ClientUpdateOneWithoutStudentsInput {
  create?: ClientCreateWithoutStudentsInput;
  update?: ClientUpdateWithoutStudentsDataInput;
  upsert?: ClientUpsertWithoutStudentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ClientWhereUniqueInput;
}

export interface ClientUpdateWithoutStudentsDataInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  phone?: String;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface ClientUpsertWithoutStudentsInput {
  update: ClientUpdateWithoutStudentsDataInput;
  create: ClientCreateWithoutStudentsInput;
}

export interface StudentUpsertWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutClassesDataInput;
  create: StudentCreateWithoutClassesInput;
}

export interface StudentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  birthday?: String;
  birthday_not?: String;
  birthday_in?: String[] | String;
  birthday_not_in?: String[] | String;
  birthday_lt?: String;
  birthday_lte?: String;
  birthday_gt?: String;
  birthday_gte?: String;
  birthday_contains?: String;
  birthday_not_contains?: String;
  birthday_starts_with?: String;
  birthday_not_starts_with?: String;
  birthday_ends_with?: String;
  birthday_not_ends_with?: String;
  skill?: SkillLevel;
  skill_not?: SkillLevel;
  skill_in?: SkillLevel[] | SkillLevel;
  skill_not_in?: SkillLevel[] | SkillLevel;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  OR?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  NOT?: StudentScalarWhereInput[] | StudentScalarWhereInput;
}

export interface StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput;
  data: StudentUpdateManyDataInput;
}

export interface StudentUpdateManyDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  gender?: Gender;
}

export interface ClassUpsertWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutInstructorDataInput;
  create: ClassCreateWithoutInstructorInput;
}

export interface EmployeeUpsertWithoutLessonsInput {
  update: EmployeeUpdateWithoutLessonsDataInput;
  create: EmployeeCreateWithoutLessonsInput;
}

export interface LessonUpsertWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutClientDataInput;
  create: LessonCreateWithoutClientInput;
}

export interface LessonScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  type?: LessonType;
  type_not?: LessonType;
  type_in?: LessonType[] | LessonType;
  type_not_in?: LessonType[] | LessonType;
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  open?: Boolean;
  open_not?: Boolean;
  AND?: LessonScalarWhereInput[] | LessonScalarWhereInput;
  OR?: LessonScalarWhereInput[] | LessonScalarWhereInput;
  NOT?: LessonScalarWhereInput[] | LessonScalarWhereInput;
}

export interface LessonUpdateManyWithWhereNestedInput {
  where: LessonScalarWhereInput;
  data: LessonUpdateManyDataInput;
}

export interface LessonUpdateManyDataInput {
  duration?: Int;
  type?: LessonType;
  day?: Day;
  time?: String;
  open?: Boolean;
}

export interface StudentUpsertWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateDataInput;
  create: StudentCreateInput;
}

export interface LessonUpdateManyWithoutInstructorInput {
  create?:
    | LessonCreateWithoutInstructorInput[]
    | LessonCreateWithoutInstructorInput;
  delete?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  connect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  set?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  disconnect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  update?:
    | LessonUpdateWithWhereUniqueWithoutInstructorInput[]
    | LessonUpdateWithWhereUniqueWithoutInstructorInput;
  upsert?:
    | LessonUpsertWithWhereUniqueWithoutInstructorInput[]
    | LessonUpsertWithWhereUniqueWithoutInstructorInput;
  deleteMany?: LessonScalarWhereInput[] | LessonScalarWhereInput;
  updateMany?:
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput;
}

export interface LessonUpdateWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutInstructorDataInput;
}

export interface LessonUpdateWithoutInstructorDataInput {
  client?: StudentUpdateManyWithoutLessonsInput;
  duration?: Int;
  type?: LessonType;
  day?: Day;
  time?: String;
  open?: Boolean;
}

export interface StudentUpdateManyWithoutLessonsInput {
  create?:
    | StudentCreateWithoutLessonsInput[]
    | StudentCreateWithoutLessonsInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutLessonsInput[]
    | StudentUpdateWithWhereUniqueWithoutLessonsInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutLessonsInput[]
    | StudentUpsertWithWhereUniqueWithoutLessonsInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutLessonsDataInput;
}

export interface StudentUpdateWithoutLessonsDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
  admin?: ClientUpdateOneWithoutStudentsInput;
}

export interface StudentUpsertWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutLessonsDataInput;
  create: StudentCreateWithoutLessonsInput;
}

export interface LessonUpsertWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutInstructorDataInput;
  create: LessonCreateWithoutInstructorInput;
}

export interface EmployeeUpsertWithoutClassesInput {
  update: EmployeeUpdateWithoutClassesDataInput;
  create: EmployeeCreateWithoutClassesInput;
}

export interface ClassUpdateManyMutationInput {
  name?: String;
  description?: String;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  duration?: Int;
  time?: String;
}

export interface ClientCreateInput {
  id?: ID_Input;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  students?: StudentCreateManyWithoutAdminInput;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface StudentCreateManyWithoutAdminInput {
  create?: StudentCreateWithoutAdminInput[] | StudentCreateWithoutAdminInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutAdminInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: ClassCreateManyWithoutStudentsInput;
  lessons?: LessonCreateManyWithoutClientInput;
  gender: Gender;
  medical?: MedicalConditionCreateManyWithoutStudentInput;
}

export interface ClientUpdateInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  phone?: String;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  students?: StudentUpdateManyWithoutAdminInput;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface StudentUpdateManyWithoutAdminInput {
  create?: StudentCreateWithoutAdminInput[] | StudentCreateWithoutAdminInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutAdminInput[]
    | StudentUpdateWithWhereUniqueWithoutAdminInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutAdminInput[]
    | StudentUpsertWithWhereUniqueWithoutAdminInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutAdminInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutAdminDataInput;
}

export interface StudentUpdateWithoutAdminDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
}

export interface StudentUpsertWithWhereUniqueWithoutAdminInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutAdminDataInput;
  create: StudentCreateWithoutAdminInput;
}

export interface ClientUpdateManyMutationInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  phone?: String;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface EmployeeCreateInput {
  id?: ID_Input;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role?: EmployeeCreateroleInput;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentCreateManyInput;
  classes?: ClassCreateManyWithoutInstructorInput;
  lessons?: LessonCreateManyWithoutInstructorInput;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
}

export interface EmployeeUpdateInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: EmployeeUpdateroleInput;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentUpdateManyInput;
  classes?: ClassUpdateManyWithoutInstructorInput;
  lessons?: LessonUpdateManyWithoutInstructorInput;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
}

export interface EmployeeUpdateManyMutationInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: EmployeeUpdateroleInput;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
}

export interface LessonCreateInput {
  id?: ID_Input;
  instructor: EmployeeCreateOneWithoutLessonsInput;
  client?: StudentCreateManyWithoutLessonsInput;
  duration: Int;
  type?: LessonType;
  day: Day;
  time: String;
  open: Boolean;
}

export interface LessonUpdateInput {
  instructor?: EmployeeUpdateOneRequiredWithoutLessonsInput;
  client?: StudentUpdateManyWithoutLessonsInput;
  duration?: Int;
  type?: LessonType;
  day?: Day;
  time?: String;
  open?: Boolean;
}

export interface LessonUpdateManyMutationInput {
  duration?: Int;
  type?: LessonType;
  day?: Day;
  time?: String;
  open?: Boolean;
}

export interface MedicalConditionCreateInput {
  id?: ID_Input;
  description: String;
  student?: StudentCreateOneWithoutMedicalInput;
}

export interface StudentCreateOneWithoutMedicalInput {
  create?: StudentCreateWithoutMedicalInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentCreateWithoutMedicalInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: ClassCreateManyWithoutStudentsInput;
  lessons?: LessonCreateManyWithoutClientInput;
  gender: Gender;
  admin?: ClientCreateOneWithoutStudentsInput;
}

export interface MedicalConditionUpdateInput {
  description?: String;
  student?: StudentUpdateOneWithoutMedicalInput;
}

export interface StudentUpdateOneWithoutMedicalInput {
  create?: StudentCreateWithoutMedicalInput;
  update?: StudentUpdateWithoutMedicalDataInput;
  upsert?: StudentUpsertWithoutMedicalInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateWithoutMedicalDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  admin?: ClientUpdateOneWithoutStudentsInput;
}

export interface StudentUpsertWithoutMedicalInput {
  update: StudentUpdateWithoutMedicalDataInput;
  create: StudentCreateWithoutMedicalInput;
}

export interface MedicalConditionUpdateManyMutationInput {
  description?: String;
}

export interface StudentUpdateInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
  admin?: ClientUpdateOneWithoutStudentsInput;
}

export interface StudentUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  gender?: Gender;
}

export interface AgeGroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AgeGroupWhereInput;
  AND?: AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput;
  OR?: AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput;
  NOT?: AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput;
}

export interface ClassSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClassWhereInput;
  AND?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
  OR?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
  NOT?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
}

export interface ClientSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClientWhereInput;
  AND?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
  OR?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
  NOT?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EmployeeWhereInput;
  AND?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  OR?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  NOT?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
}

export interface LessonSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LessonWhereInput;
  AND?: LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput;
  OR?: LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput;
  NOT?: LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput;
}

export interface MedicalConditionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MedicalConditionWhereInput;
  AND?:
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput;
  OR?:
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput;
  NOT?:
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentWhereInput;
  AND?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  OR?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  NOT?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AgeGroup {
  id: ID_Output;
  name: String;
  minAge: Int;
  maxAge?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AgeGroupPromise extends Promise<AgeGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupSubscription
  extends Promise<AsyncIterator<AgeGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  minAge: () => Promise<AsyncIterator<Int>>;
  maxAge: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AgeGroupConnection {
  pageInfo: PageInfo;
  edges: AgeGroupEdge[];
}

export interface AgeGroupConnectionPromise
  extends Promise<AgeGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgeGroupEdge>>() => T;
  aggregate: <T = AggregateAgeGroupPromise>() => T;
}

export interface AgeGroupConnectionSubscription
  extends Promise<AsyncIterator<AgeGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgeGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgeGroupSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AgeGroupEdge {
  node: AgeGroup;
  cursor: String;
}

export interface AgeGroupEdgePromise
  extends Promise<AgeGroupEdge>,
    Fragmentable {
  node: <T = AgeGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgeGroupEdgeSubscription
  extends Promise<AsyncIterator<AgeGroupEdge>>,
    Fragmentable {
  node: <T = AgeGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAgeGroup {
  count: Int;
}

export interface AggregateAgeGroupPromise
  extends Promise<AggregateAgeGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgeGroupSubscription
  extends Promise<AsyncIterator<AggregateAgeGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Class {
  id: ID_Output;
  name?: String;
  description: String;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  time: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPromise extends Promise<Class>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  ageGroup: <T = AgeGroupPromise>() => T;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  instructor: <T = EmployeePromise>() => T;
  duration: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassSubscription
  extends Promise<AsyncIterator<Class>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  ageGroup: <T = AgeGroupSubscription>() => T;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  instructor: <T = EmployeeSubscription>() => T;
  duration: () => Promise<AsyncIterator<Int>>;
  students: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Employee {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role[];
  imageURL: String;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role[]>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  clients: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessonSinglePrice: () => Promise<Int>;
  lessonDoublePrice: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  bio: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role[]>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  clients: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessonSinglePrice: () => Promise<AsyncIterator<Int>>;
  lessonDoublePrice: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Student {
  id: ID_Output;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  gender: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  skill: () => Promise<SkillLevel>;
  ageGroup: <T = AgeGroupPromise>() => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<Gender>;
  medical: <T = FragmentableArray<MedicalCondition>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admin: <T = ClientPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  skill: () => Promise<AsyncIterator<SkillLevel>>;
  ageGroup: <T = AgeGroupSubscription>() => T;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<AsyncIterator<Gender>>;
  medical: <T = Promise<AsyncIterator<MedicalConditionSubscription>>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admin: <T = ClientSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Lesson {
  id: ID_Output;
  duration: Int;
  type?: LessonType;
  day: Day;
  time: String;
  open: Boolean;
}

export interface LessonPromise extends Promise<Lesson>, Fragmentable {
  id: () => Promise<ID_Output>;
  instructor: <T = EmployeePromise>() => T;
  client: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Int>;
  type: () => Promise<LessonType>;
  day: () => Promise<Day>;
  time: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface LessonSubscription
  extends Promise<AsyncIterator<Lesson>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  instructor: <T = EmployeeSubscription>() => T;
  client: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<LessonType>>;
  day: () => Promise<AsyncIterator<Day>>;
  time: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface MedicalCondition {
  id: ID_Output;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicalConditionPromise
  extends Promise<MedicalCondition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  student: <T = StudentPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicalConditionSubscription
  extends Promise<AsyncIterator<MedicalCondition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  student: <T = StudentSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Client {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClientPromise extends Promise<Client>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClientSubscription
  extends Promise<AsyncIterator<Client>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  students: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassConnection {
  pageInfo: PageInfo;
  edges: ClassEdge[];
}

export interface ClassConnectionPromise
  extends Promise<ClassConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassEdge>>() => T;
  aggregate: <T = AggregateClassPromise>() => T;
}

export interface ClassConnectionSubscription
  extends Promise<AsyncIterator<ClassConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassSubscription>() => T;
}

export interface ClassEdge {
  node: Class;
  cursor: String;
}

export interface ClassEdgePromise extends Promise<ClassEdge>, Fragmentable {
  node: <T = ClassPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassEdgeSubscription
  extends Promise<AsyncIterator<ClassEdge>>,
    Fragmentable {
  node: <T = ClassSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClass {
  count: Int;
}

export interface AggregateClassPromise
  extends Promise<AggregateClass>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassSubscription
  extends Promise<AsyncIterator<AggregateClass>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClientConnection {
  pageInfo: PageInfo;
  edges: ClientEdge[];
}

export interface ClientConnectionPromise
  extends Promise<ClientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClientEdge>>() => T;
  aggregate: <T = AggregateClientPromise>() => T;
}

export interface ClientConnectionSubscription
  extends Promise<AsyncIterator<ClientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClientSubscription>() => T;
}

export interface ClientEdge {
  node: Client;
  cursor: String;
}

export interface ClientEdgePromise extends Promise<ClientEdge>, Fragmentable {
  node: <T = ClientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClientEdgeSubscription
  extends Promise<AsyncIterator<ClientEdge>>,
    Fragmentable {
  node: <T = ClientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClient {
  count: Int;
}

export interface AggregateClientPromise
  extends Promise<AggregateClient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClientSubscription
  extends Promise<AsyncIterator<AggregateClient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeConnection {
  pageInfo: PageInfo;
  edges: EmployeeEdge[];
}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface EmployeeEdge {
  node: Employee;
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LessonConnection {
  pageInfo: PageInfo;
  edges: LessonEdge[];
}

export interface LessonConnectionPromise
  extends Promise<LessonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LessonEdge>>() => T;
  aggregate: <T = AggregateLessonPromise>() => T;
}

export interface LessonConnectionSubscription
  extends Promise<AsyncIterator<LessonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LessonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLessonSubscription>() => T;
}

export interface LessonEdge {
  node: Lesson;
  cursor: String;
}

export interface LessonEdgePromise extends Promise<LessonEdge>, Fragmentable {
  node: <T = LessonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LessonEdgeSubscription
  extends Promise<AsyncIterator<LessonEdge>>,
    Fragmentable {
  node: <T = LessonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLesson {
  count: Int;
}

export interface AggregateLessonPromise
  extends Promise<AggregateLesson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLessonSubscription
  extends Promise<AsyncIterator<AggregateLesson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MedicalConditionConnection {
  pageInfo: PageInfo;
  edges: MedicalConditionEdge[];
}

export interface MedicalConditionConnectionPromise
  extends Promise<MedicalConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MedicalConditionEdge>>() => T;
  aggregate: <T = AggregateMedicalConditionPromise>() => T;
}

export interface MedicalConditionConnectionSubscription
  extends Promise<AsyncIterator<MedicalConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MedicalConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMedicalConditionSubscription>() => T;
}

export interface MedicalConditionEdge {
  node: MedicalCondition;
  cursor: String;
}

export interface MedicalConditionEdgePromise
  extends Promise<MedicalConditionEdge>,
    Fragmentable {
  node: <T = MedicalConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MedicalConditionEdgeSubscription
  extends Promise<AsyncIterator<MedicalConditionEdge>>,
    Fragmentable {
  node: <T = MedicalConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMedicalCondition {
  count: Int;
}

export interface AggregateMedicalConditionPromise
  extends Promise<AggregateMedicalCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMedicalConditionSubscription
  extends Promise<AsyncIterator<AggregateMedicalCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AgeGroupSubscriptionPayload {
  mutation: MutationType;
  node: AgeGroup;
  updatedFields: String[];
  previousValues: AgeGroupPreviousValues;
}

export interface AgeGroupSubscriptionPayloadPromise
  extends Promise<AgeGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgeGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgeGroupPreviousValuesPromise>() => T;
}

export interface AgeGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgeGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgeGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgeGroupPreviousValuesSubscription>() => T;
}

export interface AgeGroupPreviousValues {
  id: ID_Output;
  name: String;
  minAge: Int;
  maxAge?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AgeGroupPreviousValuesPromise
  extends Promise<AgeGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<AgeGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  minAge: () => Promise<AsyncIterator<Int>>;
  maxAge: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassSubscriptionPayload {
  mutation: MutationType;
  node: Class;
  updatedFields: String[];
  previousValues: ClassPreviousValues;
}

export interface ClassSubscriptionPayloadPromise
  extends Promise<ClassSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassPreviousValuesPromise>() => T;
}

export interface ClassSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassPreviousValuesSubscription>() => T;
}

export interface ClassPreviousValues {
  id: ID_Output;
  name?: String;
  description: String;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  time: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPreviousValuesPromise
  extends Promise<ClassPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  duration: () => Promise<Int>;
  time: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  duration: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClientSubscriptionPayload {
  mutation: MutationType;
  node: Client;
  updatedFields: String[];
  previousValues: ClientPreviousValues;
}

export interface ClientSubscriptionPayloadPromise
  extends Promise<ClientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClientPreviousValuesPromise>() => T;
}

export interface ClientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClientPreviousValuesSubscription>() => T;
}

export interface ClientPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClientPreviousValuesPromise
  extends Promise<ClientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClientPreviousValuesSubscription
  extends Promise<AsyncIterator<ClientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  stripeId: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  node: Employee;
  updatedFields: String[];
  previousValues: EmployeePreviousValues;
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface EmployeePreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role[];
  imageURL: String;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role[]>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  lessonSinglePrice: () => Promise<Int>;
  lessonDoublePrice: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  bio: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role[]>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  lessonSinglePrice: () => Promise<AsyncIterator<Int>>;
  lessonDoublePrice: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LessonSubscriptionPayload {
  mutation: MutationType;
  node: Lesson;
  updatedFields: String[];
  previousValues: LessonPreviousValues;
}

export interface LessonSubscriptionPayloadPromise
  extends Promise<LessonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LessonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LessonPreviousValuesPromise>() => T;
}

export interface LessonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LessonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LessonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LessonPreviousValuesSubscription>() => T;
}

export interface LessonPreviousValues {
  id: ID_Output;
  duration: Int;
  type?: LessonType;
  day: Day;
  time: String;
  open: Boolean;
}

export interface LessonPreviousValuesPromise
  extends Promise<LessonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  duration: () => Promise<Int>;
  type: () => Promise<LessonType>;
  day: () => Promise<Day>;
  time: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface LessonPreviousValuesSubscription
  extends Promise<AsyncIterator<LessonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  duration: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<LessonType>>;
  day: () => Promise<AsyncIterator<Day>>;
  time: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface MedicalConditionSubscriptionPayload {
  mutation: MutationType;
  node: MedicalCondition;
  updatedFields: String[];
  previousValues: MedicalConditionPreviousValues;
}

export interface MedicalConditionSubscriptionPayloadPromise
  extends Promise<MedicalConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MedicalConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MedicalConditionPreviousValuesPromise>() => T;
}

export interface MedicalConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MedicalConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MedicalConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MedicalConditionPreviousValuesSubscription>() => T;
}

export interface MedicalConditionPreviousValues {
  id: ID_Output;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicalConditionPreviousValuesPromise
  extends Promise<MedicalConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicalConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<MedicalConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  gender: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  skill: () => Promise<SkillLevel>;
  gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  skill: () => Promise<AsyncIterator<SkillLevel>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "SkillLevel",
    embedded: false
  },
  {
    name: "LessonType",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "Client",
    embedded: false
  },
  {
    name: "Employee",
    embedded: false
  },
  {
    name: "MedicalCondition",
    embedded: false
  },
  {
    name: "Class",
    embedded: false
  },
  {
    name: "Lesson",
    embedded: false
  },
  {
    name: "AgeGroup",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
