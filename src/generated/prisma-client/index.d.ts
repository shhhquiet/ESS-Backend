// Code generated by Prisma (prisma@1.32.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  accountAdmin: (where?: AccountAdminWhereInput) => Promise<boolean>;
  ageGroup: (where?: AgeGroupWhereInput) => Promise<boolean>;
  class: (where?: ClassWhereInput) => Promise<boolean>;
  frontDesk: (where?: FrontDeskWhereInput) => Promise<boolean>;
  instructor: (where?: InstructorWhereInput) => Promise<boolean>;
  lesson: (where?: LessonWhereInput) => Promise<boolean>;
  medicalCondition: (where?: MedicalConditionWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  accountAdmin: (
    where: AccountAdminWhereUniqueInput
  ) => AccountAdminNullablePromise;
  accountAdmins: (args?: {
    where?: AccountAdminWhereInput;
    orderBy?: AccountAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AccountAdmin>;
  accountAdminsConnection: (args?: {
    where?: AccountAdminWhereInput;
    orderBy?: AccountAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccountAdminConnectionPromise;
  ageGroup: (where: AgeGroupWhereUniqueInput) => AgeGroupNullablePromise;
  ageGroups: (args?: {
    where?: AgeGroupWhereInput;
    orderBy?: AgeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AgeGroup>;
  ageGroupsConnection: (args?: {
    where?: AgeGroupWhereInput;
    orderBy?: AgeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AgeGroupConnectionPromise;
  class: (where: ClassWhereUniqueInput) => ClassNullablePromise;
  classes: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Class>;
  classesConnection: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassConnectionPromise;
  frontDesk: (where: FrontDeskWhereUniqueInput) => FrontDeskNullablePromise;
  frontDesks: (args?: {
    where?: FrontDeskWhereInput;
    orderBy?: FrontDeskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FrontDesk>;
  frontDesksConnection: (args?: {
    where?: FrontDeskWhereInput;
    orderBy?: FrontDeskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FrontDeskConnectionPromise;
  instructor: (where: InstructorWhereUniqueInput) => InstructorNullablePromise;
  instructors: (args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Instructor>;
  instructorsConnection: (args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InstructorConnectionPromise;
  lesson: (where: LessonWhereUniqueInput) => LessonNullablePromise;
  lessons: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lesson>;
  lessonsConnection: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LessonConnectionPromise;
  medicalCondition: (
    where: MedicalConditionWhereUniqueInput
  ) => MedicalConditionNullablePromise;
  medicalConditions: (args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MedicalCondition>;
  medicalConditionsConnection: (args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MedicalConditionConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentNullablePromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccountAdmin: (data: AccountAdminCreateInput) => AccountAdminPromise;
  updateAccountAdmin: (args: {
    data: AccountAdminUpdateInput;
    where: AccountAdminWhereUniqueInput;
  }) => AccountAdminPromise;
  updateManyAccountAdmins: (args: {
    data: AccountAdminUpdateManyMutationInput;
    where?: AccountAdminWhereInput;
  }) => BatchPayloadPromise;
  upsertAccountAdmin: (args: {
    where: AccountAdminWhereUniqueInput;
    create: AccountAdminCreateInput;
    update: AccountAdminUpdateInput;
  }) => AccountAdminPromise;
  deleteAccountAdmin: (
    where: AccountAdminWhereUniqueInput
  ) => AccountAdminPromise;
  deleteManyAccountAdmins: (
    where?: AccountAdminWhereInput
  ) => BatchPayloadPromise;
  createAgeGroup: (data: AgeGroupCreateInput) => AgeGroupPromise;
  updateAgeGroup: (args: {
    data: AgeGroupUpdateInput;
    where: AgeGroupWhereUniqueInput;
  }) => AgeGroupPromise;
  updateManyAgeGroups: (args: {
    data: AgeGroupUpdateManyMutationInput;
    where?: AgeGroupWhereInput;
  }) => BatchPayloadPromise;
  upsertAgeGroup: (args: {
    where: AgeGroupWhereUniqueInput;
    create: AgeGroupCreateInput;
    update: AgeGroupUpdateInput;
  }) => AgeGroupPromise;
  deleteAgeGroup: (where: AgeGroupWhereUniqueInput) => AgeGroupPromise;
  deleteManyAgeGroups: (where?: AgeGroupWhereInput) => BatchPayloadPromise;
  createClass: (data: ClassCreateInput) => ClassPromise;
  updateClass: (args: {
    data: ClassUpdateInput;
    where: ClassWhereUniqueInput;
  }) => ClassPromise;
  updateManyClasses: (args: {
    data: ClassUpdateManyMutationInput;
    where?: ClassWhereInput;
  }) => BatchPayloadPromise;
  upsertClass: (args: {
    where: ClassWhereUniqueInput;
    create: ClassCreateInput;
    update: ClassUpdateInput;
  }) => ClassPromise;
  deleteClass: (where: ClassWhereUniqueInput) => ClassPromise;
  deleteManyClasses: (where?: ClassWhereInput) => BatchPayloadPromise;
  createFrontDesk: (data: FrontDeskCreateInput) => FrontDeskPromise;
  updateFrontDesk: (args: {
    data: FrontDeskUpdateInput;
    where: FrontDeskWhereUniqueInput;
  }) => FrontDeskPromise;
  updateManyFrontDesks: (args: {
    data: FrontDeskUpdateManyMutationInput;
    where?: FrontDeskWhereInput;
  }) => BatchPayloadPromise;
  upsertFrontDesk: (args: {
    where: FrontDeskWhereUniqueInput;
    create: FrontDeskCreateInput;
    update: FrontDeskUpdateInput;
  }) => FrontDeskPromise;
  deleteFrontDesk: (where: FrontDeskWhereUniqueInput) => FrontDeskPromise;
  deleteManyFrontDesks: (where?: FrontDeskWhereInput) => BatchPayloadPromise;
  createInstructor: (data: InstructorCreateInput) => InstructorPromise;
  updateInstructor: (args: {
    data: InstructorUpdateInput;
    where: InstructorWhereUniqueInput;
  }) => InstructorPromise;
  updateManyInstructors: (args: {
    data: InstructorUpdateManyMutationInput;
    where?: InstructorWhereInput;
  }) => BatchPayloadPromise;
  upsertInstructor: (args: {
    where: InstructorWhereUniqueInput;
    create: InstructorCreateInput;
    update: InstructorUpdateInput;
  }) => InstructorPromise;
  deleteInstructor: (where: InstructorWhereUniqueInput) => InstructorPromise;
  deleteManyInstructors: (where?: InstructorWhereInput) => BatchPayloadPromise;
  createLesson: (data: LessonCreateInput) => LessonPromise;
  updateLesson: (args: {
    data: LessonUpdateInput;
    where: LessonWhereUniqueInput;
  }) => LessonPromise;
  updateManyLessons: (args: {
    data: LessonUpdateManyMutationInput;
    where?: LessonWhereInput;
  }) => BatchPayloadPromise;
  upsertLesson: (args: {
    where: LessonWhereUniqueInput;
    create: LessonCreateInput;
    update: LessonUpdateInput;
  }) => LessonPromise;
  deleteLesson: (where: LessonWhereUniqueInput) => LessonPromise;
  deleteManyLessons: (where?: LessonWhereInput) => BatchPayloadPromise;
  createMedicalCondition: (
    data: MedicalConditionCreateInput
  ) => MedicalConditionPromise;
  updateMedicalCondition: (args: {
    data: MedicalConditionUpdateInput;
    where: MedicalConditionWhereUniqueInput;
  }) => MedicalConditionPromise;
  updateManyMedicalConditions: (args: {
    data: MedicalConditionUpdateManyMutationInput;
    where?: MedicalConditionWhereInput;
  }) => BatchPayloadPromise;
  upsertMedicalCondition: (args: {
    where: MedicalConditionWhereUniqueInput;
    create: MedicalConditionCreateInput;
    update: MedicalConditionUpdateInput;
  }) => MedicalConditionPromise;
  deleteMedicalCondition: (
    where: MedicalConditionWhereUniqueInput
  ) => MedicalConditionPromise;
  deleteManyMedicalConditions: (
    where?: MedicalConditionWhereInput
  ) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accountAdmin: (
    where?: AccountAdminSubscriptionWhereInput
  ) => AccountAdminSubscriptionPayloadSubscription;
  ageGroup: (
    where?: AgeGroupSubscriptionWhereInput
  ) => AgeGroupSubscriptionPayloadSubscription;
  class: (
    where?: ClassSubscriptionWhereInput
  ) => ClassSubscriptionPayloadSubscription;
  frontDesk: (
    where?: FrontDeskSubscriptionWhereInput
  ) => FrontDeskSubscriptionPayloadSubscription;
  instructor: (
    where?: InstructorSubscriptionWhereInput
  ) => InstructorSubscriptionPayloadSubscription;
  lesson: (
    where?: LessonSubscriptionWhereInput
  ) => LessonSubscriptionPayloadSubscription;
  medicalCondition: (
    where?: MedicalConditionSubscriptionWhereInput
  ) => MedicalConditionSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SkillLevel = "BEGINNER" | "INTERMEDIATE" | "ADVANCED";

export type Gender = "MALE" | "FEMALE";

export type Role = "ADMIN" | "INSTRUCTOR" | "FRONT_DESK";

export type Day =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY";

export type Color =
  | "RED"
  | "BLUE"
  | "BLACK"
  | "PURPLE"
  | "PINK"
  | "GREEN"
  | "ORANGE"
  | "GREY"
  | "YELLOW";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "skill_ASC"
  | "skill_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InstructorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "role_ASC"
  | "role_DESC"
  | "imageURL_ASC"
  | "imageURL_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "currentEmployee_ASC"
  | "currentEmployee_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClassOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "level_ASC"
  | "level_DESC"
  | "capacity_ASC"
  | "capacity_DESC"
  | "price_ASC"
  | "price_DESC"
  | "day_ASC"
  | "day_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "time_ASC"
  | "time_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LessonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "calendarColor_ASC"
  | "calendarColor_DESC"
  | "price_ASC"
  | "price_DESC"
  | "day_ASC"
  | "day_DESC"
  | "time_ASC"
  | "time_DESC"
  | "open_ASC"
  | "open_DESC";

export type MedicalConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AccountAdminOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "stripeId_ASC"
  | "stripeId_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AgeGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "minAge_ASC"
  | "minAge_DESC"
  | "maxAge_ASC"
  | "maxAge_DESC"
  | "level_ASC"
  | "level_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FrontDeskOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "role_ASC"
  | "role_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "currentEmployee_ASC"
  | "currentEmployee_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AccountAdminWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface StudentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  birthday?: Maybe<String>;
  birthday_not?: Maybe<String>;
  birthday_in?: Maybe<String[] | String>;
  birthday_not_in?: Maybe<String[] | String>;
  birthday_lt?: Maybe<String>;
  birthday_lte?: Maybe<String>;
  birthday_gt?: Maybe<String>;
  birthday_gte?: Maybe<String>;
  birthday_contains?: Maybe<String>;
  birthday_not_contains?: Maybe<String>;
  birthday_starts_with?: Maybe<String>;
  birthday_not_starts_with?: Maybe<String>;
  birthday_ends_with?: Maybe<String>;
  birthday_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  skill_not?: Maybe<SkillLevel>;
  skill_in?: Maybe<SkillLevel[] | SkillLevel>;
  skill_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  ageGroup?: Maybe<AgeGroupWhereInput>;
  classes_every?: Maybe<ClassWhereInput>;
  classes_some?: Maybe<ClassWhereInput>;
  classes_none?: Maybe<ClassWhereInput>;
  lessons_every?: Maybe<LessonWhereInput>;
  lessons_some?: Maybe<LessonWhereInput>;
  lessons_none?: Maybe<LessonWhereInput>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  medical_every?: Maybe<MedicalConditionWhereInput>;
  medical_some?: Maybe<MedicalConditionWhereInput>;
  medical_none?: Maybe<MedicalConditionWhereInput>;
  parent?: Maybe<AccountAdminWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StudentWhereInput[] | StudentWhereInput>;
  OR?: Maybe<StudentWhereInput[] | StudentWhereInput>;
  NOT?: Maybe<StudentWhereInput[] | StudentWhereInput>;
}

export interface AgeGroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  minAge?: Maybe<Int>;
  minAge_not?: Maybe<Int>;
  minAge_in?: Maybe<Int[] | Int>;
  minAge_not_in?: Maybe<Int[] | Int>;
  minAge_lt?: Maybe<Int>;
  minAge_lte?: Maybe<Int>;
  minAge_gt?: Maybe<Int>;
  minAge_gte?: Maybe<Int>;
  maxAge?: Maybe<Int>;
  maxAge_not?: Maybe<Int>;
  maxAge_in?: Maybe<Int[] | Int>;
  maxAge_not_in?: Maybe<Int[] | Int>;
  maxAge_lt?: Maybe<Int>;
  maxAge_lte?: Maybe<Int>;
  maxAge_gt?: Maybe<Int>;
  maxAge_gte?: Maybe<Int>;
  level?: Maybe<SkillLevel>;
  level_not?: Maybe<SkillLevel>;
  level_in?: Maybe<SkillLevel[] | SkillLevel>;
  level_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  instructors_every?: Maybe<InstructorWhereInput>;
  instructors_some?: Maybe<InstructorWhereInput>;
  instructors_none?: Maybe<InstructorWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AgeGroupWhereInput[] | AgeGroupWhereInput>;
  OR?: Maybe<AgeGroupWhereInput[] | AgeGroupWhereInput>;
  NOT?: Maybe<AgeGroupWhereInput[] | AgeGroupWhereInput>;
}

export interface InstructorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  imageURL?: Maybe<String>;
  imageURL_not?: Maybe<String>;
  imageURL_in?: Maybe<String[] | String>;
  imageURL_not_in?: Maybe<String[] | String>;
  imageURL_lt?: Maybe<String>;
  imageURL_lte?: Maybe<String>;
  imageURL_gt?: Maybe<String>;
  imageURL_gte?: Maybe<String>;
  imageURL_contains?: Maybe<String>;
  imageURL_not_contains?: Maybe<String>;
  imageURL_starts_with?: Maybe<String>;
  imageURL_not_starts_with?: Maybe<String>;
  imageURL_ends_with?: Maybe<String>;
  imageURL_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  currentEmployee_not?: Maybe<Boolean>;
  clients_every?: Maybe<StudentWhereInput>;
  clients_some?: Maybe<StudentWhereInput>;
  clients_none?: Maybe<StudentWhereInput>;
  classes_every?: Maybe<ClassWhereInput>;
  classes_some?: Maybe<ClassWhereInput>;
  classes_none?: Maybe<ClassWhereInput>;
  lessons_every?: Maybe<LessonWhereInput>;
  lessons_some?: Maybe<LessonWhereInput>;
  lessons_none?: Maybe<LessonWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InstructorWhereInput[] | InstructorWhereInput>;
  OR?: Maybe<InstructorWhereInput[] | InstructorWhereInput>;
  NOT?: Maybe<InstructorWhereInput[] | InstructorWhereInput>;
}

export interface ClassWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  ageGroup?: Maybe<AgeGroupWhereInput>;
  level?: Maybe<SkillLevel>;
  level_not?: Maybe<SkillLevel>;
  level_in?: Maybe<SkillLevel[] | SkillLevel>;
  level_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  capacity?: Maybe<Int>;
  capacity_not?: Maybe<Int>;
  capacity_in?: Maybe<Int[] | Int>;
  capacity_not_in?: Maybe<Int[] | Int>;
  capacity_lt?: Maybe<Int>;
  capacity_lte?: Maybe<Int>;
  capacity_gt?: Maybe<Int>;
  capacity_gte?: Maybe<Int>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  instructor?: Maybe<InstructorWhereInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  students_every?: Maybe<StudentWhereInput>;
  students_some?: Maybe<StudentWhereInput>;
  students_none?: Maybe<StudentWhereInput>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClassWhereInput[] | ClassWhereInput>;
  OR?: Maybe<ClassWhereInput[] | ClassWhereInput>;
  NOT?: Maybe<ClassWhereInput[] | ClassWhereInput>;
}

export interface LessonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  instructor?: Maybe<InstructorWhereInput>;
  client_every?: Maybe<StudentWhereInput>;
  client_some?: Maybe<StudentWhereInput>;
  client_none?: Maybe<StudentWhereInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  calendarColor?: Maybe<Color>;
  calendarColor_not?: Maybe<Color>;
  calendarColor_in?: Maybe<Color[] | Color>;
  calendarColor_not_in?: Maybe<Color[] | Color>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  open?: Maybe<Boolean>;
  open_not?: Maybe<Boolean>;
  AND?: Maybe<LessonWhereInput[] | LessonWhereInput>;
  OR?: Maybe<LessonWhereInput[] | LessonWhereInput>;
  NOT?: Maybe<LessonWhereInput[] | LessonWhereInput>;
}

export interface MedicalConditionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  student_every?: Maybe<StudentWhereInput>;
  student_some?: Maybe<StudentWhereInput>;
  student_none?: Maybe<StudentWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MedicalConditionWhereInput[] | MedicalConditionWhereInput>;
  OR?: Maybe<MedicalConditionWhereInput[] | MedicalConditionWhereInput>;
  NOT?: Maybe<MedicalConditionWhereInput[] | MedicalConditionWhereInput>;
}

export interface AccountAdminWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  children_every?: Maybe<StudentWhereInput>;
  children_some?: Maybe<StudentWhereInput>;
  children_none?: Maybe<StudentWhereInput>;
  stripeId?: Maybe<String>;
  stripeId_not?: Maybe<String>;
  stripeId_in?: Maybe<String[] | String>;
  stripeId_not_in?: Maybe<String[] | String>;
  stripeId_lt?: Maybe<String>;
  stripeId_lte?: Maybe<String>;
  stripeId_gt?: Maybe<String>;
  stripeId_gte?: Maybe<String>;
  stripeId_contains?: Maybe<String>;
  stripeId_not_contains?: Maybe<String>;
  stripeId_starts_with?: Maybe<String>;
  stripeId_not_starts_with?: Maybe<String>;
  stripeId_ends_with?: Maybe<String>;
  stripeId_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
  resetTokenExpiry_not?: Maybe<String>;
  resetTokenExpiry_in?: Maybe<String[] | String>;
  resetTokenExpiry_not_in?: Maybe<String[] | String>;
  resetTokenExpiry_lt?: Maybe<String>;
  resetTokenExpiry_lte?: Maybe<String>;
  resetTokenExpiry_gt?: Maybe<String>;
  resetTokenExpiry_gte?: Maybe<String>;
  resetTokenExpiry_contains?: Maybe<String>;
  resetTokenExpiry_not_contains?: Maybe<String>;
  resetTokenExpiry_starts_with?: Maybe<String>;
  resetTokenExpiry_not_starts_with?: Maybe<String>;
  resetTokenExpiry_ends_with?: Maybe<String>;
  resetTokenExpiry_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AccountAdminWhereInput[] | AccountAdminWhereInput>;
  OR?: Maybe<AccountAdminWhereInput[] | AccountAdminWhereInput>;
  NOT?: Maybe<AccountAdminWhereInput[] | AccountAdminWhereInput>;
}

export type AgeGroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ClassWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FrontDeskWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
}>;

export interface FrontDeskWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  currentEmployee_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FrontDeskWhereInput[] | FrontDeskWhereInput>;
  OR?: Maybe<FrontDeskWhereInput[] | FrontDeskWhereInput>;
  NOT?: Maybe<FrontDeskWhereInput[] | FrontDeskWhereInput>;
}

export type InstructorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
}>;

export type LessonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MedicalConditionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type StudentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AccountAdminCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  children?: Maybe<StudentCreateManyWithoutParentInput>;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface StudentCreateManyWithoutParentInput {
  create?: Maybe<
    StudentCreateWithoutParentInput[] | StudentCreateWithoutParentInput
  >;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  birthday: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: Maybe<ClassCreateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonCreateManyWithoutClientInput>;
  gender: Gender;
  medical?: Maybe<MedicalConditionCreateManyWithoutStudentInput>;
}

export interface AgeGroupCreateOneInput {
  create?: Maybe<AgeGroupCreateInput>;
  connect?: Maybe<AgeGroupWhereUniqueInput>;
}

export interface AgeGroupCreateInput {
  id?: Maybe<ID_Input>;
  minAge: Int;
  maxAge: Int;
  level?: Maybe<SkillLevel>;
  instructors?: Maybe<InstructorCreateManyInput>;
}

export interface InstructorCreateManyInput {
  create?: Maybe<InstructorCreateInput[] | InstructorCreateInput>;
  connect?: Maybe<InstructorWhereUniqueInput[] | InstructorWhereUniqueInput>;
}

export interface InstructorCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee: Boolean;
  clients?: Maybe<StudentCreateManyInput>;
  classes?: Maybe<ClassCreateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonCreateManyWithoutInstructorInput>;
}

export interface StudentCreateManyInput {
  create?: Maybe<StudentCreateInput[] | StudentCreateInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  birthday: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: Maybe<ClassCreateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonCreateManyWithoutClientInput>;
  gender: Gender;
  medical?: Maybe<MedicalConditionCreateManyWithoutStudentInput>;
  parent?: Maybe<AccountAdminCreateOneWithoutChildrenInput>;
}

export interface ClassCreateManyWithoutStudentsInput {
  create?: Maybe<
    ClassCreateWithoutStudentsInput[] | ClassCreateWithoutStudentsInput
  >;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
}

export interface ClassCreateWithoutStudentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  instructor: InstructorCreateOneWithoutClassesInput;
  duration: Int;
  time: DateTimeInput;
}

export interface InstructorCreateOneWithoutClassesInput {
  create?: Maybe<InstructorCreateWithoutClassesInput>;
  connect?: Maybe<InstructorWhereUniqueInput>;
}

export interface InstructorCreateWithoutClassesInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee: Boolean;
  clients?: Maybe<StudentCreateManyInput>;
  lessons?: Maybe<LessonCreateManyWithoutInstructorInput>;
}

export interface LessonCreateManyWithoutInstructorInput {
  create?: Maybe<
    LessonCreateWithoutInstructorInput[] | LessonCreateWithoutInstructorInput
  >;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
}

export interface LessonCreateWithoutInstructorInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  client?: Maybe<StudentCreateManyWithoutLessonsInput>;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeInput;
  open: Boolean;
}

export interface StudentCreateManyWithoutLessonsInput {
  create?: Maybe<
    StudentCreateWithoutLessonsInput[] | StudentCreateWithoutLessonsInput
  >;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateWithoutLessonsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  birthday: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: Maybe<ClassCreateManyWithoutStudentsInput>;
  gender: Gender;
  medical?: Maybe<MedicalConditionCreateManyWithoutStudentInput>;
  parent?: Maybe<AccountAdminCreateOneWithoutChildrenInput>;
}

export interface MedicalConditionCreateManyWithoutStudentInput {
  create?: Maybe<
    | MedicalConditionCreateWithoutStudentInput[]
    | MedicalConditionCreateWithoutStudentInput
  >;
  connect?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
}

export interface MedicalConditionCreateWithoutStudentInput {
  id?: Maybe<ID_Input>;
  description: String;
}

export interface AccountAdminCreateOneWithoutChildrenInput {
  create?: Maybe<AccountAdminCreateWithoutChildrenInput>;
  connect?: Maybe<AccountAdminWhereUniqueInput>;
}

export interface AccountAdminCreateWithoutChildrenInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface LessonCreateManyWithoutClientInput {
  create?: Maybe<
    LessonCreateWithoutClientInput[] | LessonCreateWithoutClientInput
  >;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
}

export interface LessonCreateWithoutClientInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  instructor: InstructorCreateOneWithoutLessonsInput;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeInput;
  open: Boolean;
}

export interface InstructorCreateOneWithoutLessonsInput {
  create?: Maybe<InstructorCreateWithoutLessonsInput>;
  connect?: Maybe<InstructorWhereUniqueInput>;
}

export interface InstructorCreateWithoutLessonsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee: Boolean;
  clients?: Maybe<StudentCreateManyInput>;
  classes?: Maybe<ClassCreateManyWithoutInstructorInput>;
}

export interface ClassCreateManyWithoutInstructorInput {
  create?: Maybe<
    ClassCreateWithoutInstructorInput[] | ClassCreateWithoutInstructorInput
  >;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
}

export interface ClassCreateWithoutInstructorInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  students?: Maybe<StudentCreateManyWithoutClassesInput>;
  time: DateTimeInput;
}

export interface StudentCreateManyWithoutClassesInput {
  create?: Maybe<
    StudentCreateWithoutClassesInput[] | StudentCreateWithoutClassesInput
  >;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateWithoutClassesInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  birthday: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  lessons?: Maybe<LessonCreateManyWithoutClientInput>;
  gender: Gender;
  medical?: Maybe<MedicalConditionCreateManyWithoutStudentInput>;
  parent?: Maybe<AccountAdminCreateOneWithoutChildrenInput>;
}

export interface AccountAdminUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  children?: Maybe<StudentUpdateManyWithoutParentInput>;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface StudentUpdateManyWithoutParentInput {
  create?: Maybe<
    StudentCreateWithoutParentInput[] | StudentCreateWithoutParentInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueWithoutParentInput[]
    | StudentUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueWithoutParentInput[]
    | StudentUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueWithoutParentInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutParentDataInput;
}

export interface StudentUpdateWithoutParentDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
}

export interface AgeGroupUpdateOneRequiredInput {
  create?: Maybe<AgeGroupCreateInput>;
  update?: Maybe<AgeGroupUpdateDataInput>;
  upsert?: Maybe<AgeGroupUpsertNestedInput>;
  connect?: Maybe<AgeGroupWhereUniqueInput>;
}

export interface AgeGroupUpdateDataInput {
  minAge?: Maybe<Int>;
  maxAge?: Maybe<Int>;
  level?: Maybe<SkillLevel>;
  instructors?: Maybe<InstructorUpdateManyInput>;
}

export interface InstructorUpdateManyInput {
  create?: Maybe<InstructorCreateInput[] | InstructorCreateInput>;
  update?: Maybe<
    | InstructorUpdateWithWhereUniqueNestedInput[]
    | InstructorUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | InstructorUpsertWithWhereUniqueNestedInput[]
    | InstructorUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<InstructorWhereUniqueInput[] | InstructorWhereUniqueInput>;
  connect?: Maybe<InstructorWhereUniqueInput[] | InstructorWhereUniqueInput>;
  set?: Maybe<InstructorWhereUniqueInput[] | InstructorWhereUniqueInput>;
  disconnect?: Maybe<InstructorWhereUniqueInput[] | InstructorWhereUniqueInput>;
  deleteMany?: Maybe<InstructorScalarWhereInput[] | InstructorScalarWhereInput>;
  updateMany?: Maybe<
    | InstructorUpdateManyWithWhereNestedInput[]
    | InstructorUpdateManyWithWhereNestedInput
  >;
}

export interface InstructorUpdateWithWhereUniqueNestedInput {
  where: InstructorWhereUniqueInput;
  data: InstructorUpdateDataInput;
}

export interface InstructorUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<Role>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  classes?: Maybe<ClassUpdateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonUpdateManyWithoutInstructorInput>;
}

export interface StudentUpdateManyInput {
  create?: Maybe<StudentCreateInput[] | StudentCreateInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueNestedInput[]
    | StudentUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueNestedInput[]
    | StudentUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateDataInput;
}

export interface StudentUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
  parent?: Maybe<AccountAdminUpdateOneWithoutChildrenInput>;
}

export interface ClassUpdateManyWithoutStudentsInput {
  create?: Maybe<
    ClassCreateWithoutStudentsInput[] | ClassCreateWithoutStudentsInput
  >;
  delete?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  set?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  disconnect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  update?: Maybe<
    | ClassUpdateWithWhereUniqueWithoutStudentsInput[]
    | ClassUpdateWithWhereUniqueWithoutStudentsInput
  >;
  upsert?: Maybe<
    | ClassUpsertWithWhereUniqueWithoutStudentsInput[]
    | ClassUpsertWithWhereUniqueWithoutStudentsInput
  >;
  deleteMany?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  updateMany?: Maybe<
    ClassUpdateManyWithWhereNestedInput[] | ClassUpdateManyWithWhereNestedInput
  >;
}

export interface ClassUpdateWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutStudentsDataInput;
}

export interface ClassUpdateWithoutStudentsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  instructor?: Maybe<InstructorUpdateOneRequiredWithoutClassesInput>;
  duration?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
}

export interface InstructorUpdateOneRequiredWithoutClassesInput {
  create?: Maybe<InstructorCreateWithoutClassesInput>;
  update?: Maybe<InstructorUpdateWithoutClassesDataInput>;
  upsert?: Maybe<InstructorUpsertWithoutClassesInput>;
  connect?: Maybe<InstructorWhereUniqueInput>;
}

export interface InstructorUpdateWithoutClassesDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<Role>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  lessons?: Maybe<LessonUpdateManyWithoutInstructorInput>;
}

export interface LessonUpdateManyWithoutInstructorInput {
  create?: Maybe<
    LessonCreateWithoutInstructorInput[] | LessonCreateWithoutInstructorInput
  >;
  delete?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  set?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  disconnect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  update?: Maybe<
    | LessonUpdateWithWhereUniqueWithoutInstructorInput[]
    | LessonUpdateWithWhereUniqueWithoutInstructorInput
  >;
  upsert?: Maybe<
    | LessonUpsertWithWhereUniqueWithoutInstructorInput[]
    | LessonUpsertWithWhereUniqueWithoutInstructorInput
  >;
  deleteMany?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  updateMany?: Maybe<
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput
  >;
}

export interface LessonUpdateWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutInstructorDataInput;
}

export interface LessonUpdateWithoutInstructorDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  client?: Maybe<StudentUpdateManyWithoutLessonsInput>;
  duration?: Maybe<Int>;
  calendarColor?: Maybe<Color>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  time?: Maybe<DateTimeInput>;
  open?: Maybe<Boolean>;
}

export interface StudentUpdateManyWithoutLessonsInput {
  create?: Maybe<
    StudentCreateWithoutLessonsInput[] | StudentCreateWithoutLessonsInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueWithoutLessonsInput[]
    | StudentUpdateWithWhereUniqueWithoutLessonsInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueWithoutLessonsInput[]
    | StudentUpsertWithWhereUniqueWithoutLessonsInput
  >;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutLessonsDataInput;
}

export interface StudentUpdateWithoutLessonsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
  parent?: Maybe<AccountAdminUpdateOneWithoutChildrenInput>;
}

export interface MedicalConditionUpdateManyWithoutStudentInput {
  create?: Maybe<
    | MedicalConditionCreateWithoutStudentInput[]
    | MedicalConditionCreateWithoutStudentInput
  >;
  delete?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
  connect?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
  set?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
  disconnect?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
  update?: Maybe<
    | MedicalConditionUpdateWithWhereUniqueWithoutStudentInput[]
    | MedicalConditionUpdateWithWhereUniqueWithoutStudentInput
  >;
  upsert?: Maybe<
    | MedicalConditionUpsertWithWhereUniqueWithoutStudentInput[]
    | MedicalConditionUpsertWithWhereUniqueWithoutStudentInput
  >;
  deleteMany?: Maybe<
    MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput
  >;
  updateMany?: Maybe<
    | MedicalConditionUpdateManyWithWhereNestedInput[]
    | MedicalConditionUpdateManyWithWhereNestedInput
  >;
}

export interface MedicalConditionUpdateWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput;
  data: MedicalConditionUpdateWithoutStudentDataInput;
}

export interface MedicalConditionUpdateWithoutStudentDataInput {
  description?: Maybe<String>;
}

export interface MedicalConditionUpsertWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput;
  update: MedicalConditionUpdateWithoutStudentDataInput;
  create: MedicalConditionCreateWithoutStudentInput;
}

export interface MedicalConditionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput
  >;
  OR?: Maybe<
    MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput
  >;
  NOT?: Maybe<
    MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput
  >;
}

export interface MedicalConditionUpdateManyWithWhereNestedInput {
  where: MedicalConditionScalarWhereInput;
  data: MedicalConditionUpdateManyDataInput;
}

export interface MedicalConditionUpdateManyDataInput {
  description?: Maybe<String>;
}

export interface AccountAdminUpdateOneWithoutChildrenInput {
  create?: Maybe<AccountAdminCreateWithoutChildrenInput>;
  update?: Maybe<AccountAdminUpdateWithoutChildrenDataInput>;
  upsert?: Maybe<AccountAdminUpsertWithoutChildrenInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AccountAdminWhereUniqueInput>;
}

export interface AccountAdminUpdateWithoutChildrenDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface AccountAdminUpsertWithoutChildrenInput {
  update: AccountAdminUpdateWithoutChildrenDataInput;
  create: AccountAdminCreateWithoutChildrenInput;
}

export interface StudentUpsertWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutLessonsDataInput;
  create: StudentCreateWithoutLessonsInput;
}

export interface StudentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  birthday?: Maybe<String>;
  birthday_not?: Maybe<String>;
  birthday_in?: Maybe<String[] | String>;
  birthday_not_in?: Maybe<String[] | String>;
  birthday_lt?: Maybe<String>;
  birthday_lte?: Maybe<String>;
  birthday_gt?: Maybe<String>;
  birthday_gte?: Maybe<String>;
  birthday_contains?: Maybe<String>;
  birthday_not_contains?: Maybe<String>;
  birthday_starts_with?: Maybe<String>;
  birthday_not_starts_with?: Maybe<String>;
  birthday_ends_with?: Maybe<String>;
  birthday_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  skill_not?: Maybe<SkillLevel>;
  skill_in?: Maybe<SkillLevel[] | SkillLevel>;
  skill_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  OR?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  NOT?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
}

export interface StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput;
  data: StudentUpdateManyDataInput;
}

export interface StudentUpdateManyDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  gender?: Maybe<Gender>;
}

export interface LessonUpsertWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutInstructorDataInput;
  create: LessonCreateWithoutInstructorInput;
}

export interface LessonScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  calendarColor?: Maybe<Color>;
  calendarColor_not?: Maybe<Color>;
  calendarColor_in?: Maybe<Color[] | Color>;
  calendarColor_not_in?: Maybe<Color[] | Color>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  open?: Maybe<Boolean>;
  open_not?: Maybe<Boolean>;
  AND?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  OR?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  NOT?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
}

export interface LessonUpdateManyWithWhereNestedInput {
  where: LessonScalarWhereInput;
  data: LessonUpdateManyDataInput;
}

export interface LessonUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  calendarColor?: Maybe<Color>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  time?: Maybe<DateTimeInput>;
  open?: Maybe<Boolean>;
}

export interface InstructorUpsertWithoutClassesInput {
  update: InstructorUpdateWithoutClassesDataInput;
  create: InstructorCreateWithoutClassesInput;
}

export interface ClassUpsertWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutStudentsDataInput;
  create: ClassCreateWithoutStudentsInput;
}

export interface ClassScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  level?: Maybe<SkillLevel>;
  level_not?: Maybe<SkillLevel>;
  level_in?: Maybe<SkillLevel[] | SkillLevel>;
  level_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  capacity?: Maybe<Int>;
  capacity_not?: Maybe<Int>;
  capacity_in?: Maybe<Int[] | Int>;
  capacity_not_in?: Maybe<Int[] | Int>;
  capacity_lt?: Maybe<Int>;
  capacity_lte?: Maybe<Int>;
  capacity_gt?: Maybe<Int>;
  capacity_gte?: Maybe<Int>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  OR?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  NOT?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
}

export interface ClassUpdateManyWithWhereNestedInput {
  where: ClassScalarWhereInput;
  data: ClassUpdateManyDataInput;
}

export interface ClassUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  duration?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
}

export interface LessonUpdateManyWithoutClientInput {
  create?: Maybe<
    LessonCreateWithoutClientInput[] | LessonCreateWithoutClientInput
  >;
  delete?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  set?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  disconnect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  update?: Maybe<
    | LessonUpdateWithWhereUniqueWithoutClientInput[]
    | LessonUpdateWithWhereUniqueWithoutClientInput
  >;
  upsert?: Maybe<
    | LessonUpsertWithWhereUniqueWithoutClientInput[]
    | LessonUpsertWithWhereUniqueWithoutClientInput
  >;
  deleteMany?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  updateMany?: Maybe<
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput
  >;
}

export interface LessonUpdateWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutClientDataInput;
}

export interface LessonUpdateWithoutClientDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  instructor?: Maybe<InstructorUpdateOneRequiredWithoutLessonsInput>;
  duration?: Maybe<Int>;
  calendarColor?: Maybe<Color>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  time?: Maybe<DateTimeInput>;
  open?: Maybe<Boolean>;
}

export interface InstructorUpdateOneRequiredWithoutLessonsInput {
  create?: Maybe<InstructorCreateWithoutLessonsInput>;
  update?: Maybe<InstructorUpdateWithoutLessonsDataInput>;
  upsert?: Maybe<InstructorUpsertWithoutLessonsInput>;
  connect?: Maybe<InstructorWhereUniqueInput>;
}

export interface InstructorUpdateWithoutLessonsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<Role>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  classes?: Maybe<ClassUpdateManyWithoutInstructorInput>;
}

export interface ClassUpdateManyWithoutInstructorInput {
  create?: Maybe<
    ClassCreateWithoutInstructorInput[] | ClassCreateWithoutInstructorInput
  >;
  delete?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  set?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  disconnect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  update?: Maybe<
    | ClassUpdateWithWhereUniqueWithoutInstructorInput[]
    | ClassUpdateWithWhereUniqueWithoutInstructorInput
  >;
  upsert?: Maybe<
    | ClassUpsertWithWhereUniqueWithoutInstructorInput[]
    | ClassUpsertWithWhereUniqueWithoutInstructorInput
  >;
  deleteMany?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  updateMany?: Maybe<
    ClassUpdateManyWithWhereNestedInput[] | ClassUpdateManyWithWhereNestedInput
  >;
}

export interface ClassUpdateWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutInstructorDataInput;
}

export interface ClassUpdateWithoutInstructorDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  duration?: Maybe<Int>;
  students?: Maybe<StudentUpdateManyWithoutClassesInput>;
  time?: Maybe<DateTimeInput>;
}

export interface StudentUpdateManyWithoutClassesInput {
  create?: Maybe<
    StudentCreateWithoutClassesInput[] | StudentCreateWithoutClassesInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueWithoutClassesInput[]
    | StudentUpdateWithWhereUniqueWithoutClassesInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueWithoutClassesInput[]
    | StudentUpsertWithWhereUniqueWithoutClassesInput
  >;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutClassesDataInput;
}

export interface StudentUpdateWithoutClassesDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
  parent?: Maybe<AccountAdminUpdateOneWithoutChildrenInput>;
}

export interface StudentUpsertWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutClassesDataInput;
  create: StudentCreateWithoutClassesInput;
}

export interface ClassUpsertWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutInstructorDataInput;
  create: ClassCreateWithoutInstructorInput;
}

export interface InstructorUpsertWithoutLessonsInput {
  update: InstructorUpdateWithoutLessonsDataInput;
  create: InstructorCreateWithoutLessonsInput;
}

export interface LessonUpsertWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutClientDataInput;
  create: LessonCreateWithoutClientInput;
}

export interface StudentUpsertWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateDataInput;
  create: StudentCreateInput;
}

export interface InstructorUpsertWithWhereUniqueNestedInput {
  where: InstructorWhereUniqueInput;
  update: InstructorUpdateDataInput;
  create: InstructorCreateInput;
}

export interface InstructorScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  imageURL?: Maybe<String>;
  imageURL_not?: Maybe<String>;
  imageURL_in?: Maybe<String[] | String>;
  imageURL_not_in?: Maybe<String[] | String>;
  imageURL_lt?: Maybe<String>;
  imageURL_lte?: Maybe<String>;
  imageURL_gt?: Maybe<String>;
  imageURL_gte?: Maybe<String>;
  imageURL_contains?: Maybe<String>;
  imageURL_not_contains?: Maybe<String>;
  imageURL_starts_with?: Maybe<String>;
  imageURL_not_starts_with?: Maybe<String>;
  imageURL_ends_with?: Maybe<String>;
  imageURL_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  currentEmployee_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InstructorScalarWhereInput[] | InstructorScalarWhereInput>;
  OR?: Maybe<InstructorScalarWhereInput[] | InstructorScalarWhereInput>;
  NOT?: Maybe<InstructorScalarWhereInput[] | InstructorScalarWhereInput>;
}

export interface InstructorUpdateManyWithWhereNestedInput {
  where: InstructorScalarWhereInput;
  data: InstructorUpdateManyDataInput;
}

export interface InstructorUpdateManyDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<Role>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
}

export interface AgeGroupUpsertNestedInput {
  update: AgeGroupUpdateDataInput;
  create: AgeGroupCreateInput;
}

export interface StudentUpsertWithWhereUniqueWithoutParentInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutParentDataInput;
  create: StudentCreateWithoutParentInput;
}

export interface AccountAdminUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface AgeGroupUpdateInput {
  minAge?: Maybe<Int>;
  maxAge?: Maybe<Int>;
  level?: Maybe<SkillLevel>;
  instructors?: Maybe<InstructorUpdateManyInput>;
}

export interface AgeGroupUpdateManyMutationInput {
  minAge?: Maybe<Int>;
  maxAge?: Maybe<Int>;
  level?: Maybe<SkillLevel>;
}

export interface ClassCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  instructor: InstructorCreateOneWithoutClassesInput;
  duration: Int;
  students?: Maybe<StudentCreateManyWithoutClassesInput>;
  time: DateTimeInput;
}

export interface ClassUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  instructor?: Maybe<InstructorUpdateOneRequiredWithoutClassesInput>;
  duration?: Maybe<Int>;
  students?: Maybe<StudentUpdateManyWithoutClassesInput>;
  time?: Maybe<DateTimeInput>;
}

export interface ClassUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  duration?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
}

export interface FrontDeskCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  role: Role;
  startDate: DateTimeInput;
  currentEmployee: Boolean;
}

export interface FrontDeskUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  role?: Maybe<Role>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
}

export interface FrontDeskUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  role?: Maybe<Role>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
}

export interface InstructorUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<Role>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  classes?: Maybe<ClassUpdateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonUpdateManyWithoutInstructorInput>;
}

export interface InstructorUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<Role>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
}

export interface LessonCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  instructor: InstructorCreateOneWithoutLessonsInput;
  client?: Maybe<StudentCreateManyWithoutLessonsInput>;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeInput;
  open: Boolean;
}

export interface LessonUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  instructor?: Maybe<InstructorUpdateOneRequiredWithoutLessonsInput>;
  client?: Maybe<StudentUpdateManyWithoutLessonsInput>;
  duration?: Maybe<Int>;
  calendarColor?: Maybe<Color>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  time?: Maybe<DateTimeInput>;
  open?: Maybe<Boolean>;
}

export interface LessonUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  calendarColor?: Maybe<Color>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  time?: Maybe<DateTimeInput>;
  open?: Maybe<Boolean>;
}

export interface MedicalConditionCreateInput {
  id?: Maybe<ID_Input>;
  description: String;
  student?: Maybe<StudentCreateManyWithoutMedicalInput>;
}

export interface StudentCreateManyWithoutMedicalInput {
  create?: Maybe<
    StudentCreateWithoutMedicalInput[] | StudentCreateWithoutMedicalInput
  >;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateWithoutMedicalInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  birthday: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: Maybe<ClassCreateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonCreateManyWithoutClientInput>;
  gender: Gender;
  parent?: Maybe<AccountAdminCreateOneWithoutChildrenInput>;
}

export interface MedicalConditionUpdateInput {
  description?: Maybe<String>;
  student?: Maybe<StudentUpdateManyWithoutMedicalInput>;
}

export interface StudentUpdateManyWithoutMedicalInput {
  create?: Maybe<
    StudentCreateWithoutMedicalInput[] | StudentCreateWithoutMedicalInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueWithoutMedicalInput[]
    | StudentUpdateWithWhereUniqueWithoutMedicalInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueWithoutMedicalInput[]
    | StudentUpsertWithWhereUniqueWithoutMedicalInput
  >;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueWithoutMedicalInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutMedicalDataInput;
}

export interface StudentUpdateWithoutMedicalDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  parent?: Maybe<AccountAdminUpdateOneWithoutChildrenInput>;
}

export interface StudentUpsertWithWhereUniqueWithoutMedicalInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutMedicalDataInput;
  create: StudentCreateWithoutMedicalInput;
}

export interface MedicalConditionUpdateManyMutationInput {
  description?: Maybe<String>;
}

export interface StudentUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
  parent?: Maybe<AccountAdminUpdateOneWithoutChildrenInput>;
}

export interface StudentUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  skill?: Maybe<SkillLevel>;
  gender?: Maybe<Gender>;
}

export interface AccountAdminSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AccountAdminWhereInput>;
  AND?: Maybe<
    AccountAdminSubscriptionWhereInput[] | AccountAdminSubscriptionWhereInput
  >;
  OR?: Maybe<
    AccountAdminSubscriptionWhereInput[] | AccountAdminSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AccountAdminSubscriptionWhereInput[] | AccountAdminSubscriptionWhereInput
  >;
}

export interface AgeGroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AgeGroupWhereInput>;
  AND?: Maybe<
    AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput
  >;
  OR?: Maybe<AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput>;
  NOT?: Maybe<
    AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput
  >;
}

export interface ClassSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClassWhereInput>;
  AND?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
  OR?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
  NOT?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
}

export interface FrontDeskSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FrontDeskWhereInput>;
  AND?: Maybe<
    FrontDeskSubscriptionWhereInput[] | FrontDeskSubscriptionWhereInput
  >;
  OR?: Maybe<
    FrontDeskSubscriptionWhereInput[] | FrontDeskSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FrontDeskSubscriptionWhereInput[] | FrontDeskSubscriptionWhereInput
  >;
}

export interface InstructorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InstructorWhereInput>;
  AND?: Maybe<
    InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput
  >;
  OR?: Maybe<
    InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput
  >;
}

export interface LessonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LessonWhereInput>;
  AND?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
  OR?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
  NOT?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
}

export interface MedicalConditionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MedicalConditionWhereInput>;
  AND?: Maybe<
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput
  >;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudentWhereInput>;
  AND?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
  OR?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
  NOT?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AccountAdmin {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AccountAdminPromise
  extends Promise<AccountAdmin>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  children: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountAdminSubscription
  extends Promise<AsyncIterator<AccountAdmin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  children: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AccountAdminNullablePromise
  extends Promise<AccountAdmin | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  children: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Student {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  birthday: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  skill: SkillLevel;
  gender: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  skill: () => Promise<SkillLevel>;
  ageGroup: <T = AgeGroupPromise>() => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<Gender>;
  medical: <T = FragmentableArray<MedicalCondition>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = AccountAdminPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  skill: () => Promise<AsyncIterator<SkillLevel>>;
  ageGroup: <T = AgeGroupSubscription>() => T;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<AsyncIterator<Gender>>;
  medical: <T = Promise<AsyncIterator<MedicalConditionSubscription>>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = AccountAdminSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudentNullablePromise
  extends Promise<Student | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  skill: () => Promise<SkillLevel>;
  ageGroup: <T = AgeGroupPromise>() => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<Gender>;
  medical: <T = FragmentableArray<MedicalCondition>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = AccountAdminPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroup {
  id: ID_Output;
  minAge: Int;
  maxAge: Int;
  level?: SkillLevel;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AgeGroupPromise extends Promise<AgeGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  level: () => Promise<SkillLevel>;
  instructors: <T = FragmentableArray<Instructor>>(args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupSubscription
  extends Promise<AsyncIterator<AgeGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  minAge: () => Promise<AsyncIterator<Int>>;
  maxAge: () => Promise<AsyncIterator<Int>>;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  instructors: <T = Promise<AsyncIterator<InstructorSubscription>>>(args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AgeGroupNullablePromise
  extends Promise<AgeGroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  level: () => Promise<SkillLevel>;
  instructors: <T = FragmentableArray<Instructor>>(args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Instructor {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InstructorPromise extends Promise<Instructor>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  clients: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InstructorSubscription
  extends Promise<AsyncIterator<Instructor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  bio: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  clients: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InstructorNullablePromise
  extends Promise<Instructor | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  clients: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Class {
  id: ID_Output;
  name: String;
  description: String;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  time: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPromise extends Promise<Class>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  ageGroup: <T = AgeGroupPromise>() => T;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  instructor: <T = InstructorPromise>() => T;
  duration: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassSubscription
  extends Promise<AsyncIterator<Class>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  ageGroup: <T = AgeGroupSubscription>() => T;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  instructor: <T = InstructorSubscription>() => T;
  duration: () => Promise<AsyncIterator<Int>>;
  students: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassNullablePromise
  extends Promise<Class | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  ageGroup: <T = AgeGroupPromise>() => T;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  instructor: <T = InstructorPromise>() => T;
  duration: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Lesson {
  id: ID_Output;
  name: String;
  description: String;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeOutput;
  open: Boolean;
}

export interface LessonPromise extends Promise<Lesson>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  instructor: <T = InstructorPromise>() => T;
  client: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Int>;
  calendarColor: () => Promise<Color>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  time: () => Promise<DateTimeOutput>;
  open: () => Promise<Boolean>;
}

export interface LessonSubscription
  extends Promise<AsyncIterator<Lesson>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  instructor: <T = InstructorSubscription>() => T;
  client: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<AsyncIterator<Int>>;
  calendarColor: () => Promise<AsyncIterator<Color>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface LessonNullablePromise
  extends Promise<Lesson | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  instructor: <T = InstructorPromise>() => T;
  client: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Int>;
  calendarColor: () => Promise<Color>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  time: () => Promise<DateTimeOutput>;
  open: () => Promise<Boolean>;
}

export interface MedicalCondition {
  id: ID_Output;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicalConditionPromise
  extends Promise<MedicalCondition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  student: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicalConditionSubscription
  extends Promise<AsyncIterator<MedicalCondition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  student: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MedicalConditionNullablePromise
  extends Promise<MedicalCondition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  student: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountAdminConnection {
  pageInfo: PageInfo;
  edges: AccountAdminEdge[];
}

export interface AccountAdminConnectionPromise
  extends Promise<AccountAdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountAdminEdge>>() => T;
  aggregate: <T = AggregateAccountAdminPromise>() => T;
}

export interface AccountAdminConnectionSubscription
  extends Promise<AsyncIterator<AccountAdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccountAdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccountAdminSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountAdminEdge {
  node: AccountAdmin;
  cursor: String;
}

export interface AccountAdminEdgePromise
  extends Promise<AccountAdminEdge>,
    Fragmentable {
  node: <T = AccountAdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountAdminEdgeSubscription
  extends Promise<AsyncIterator<AccountAdminEdge>>,
    Fragmentable {
  node: <T = AccountAdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccountAdmin {
  count: Int;
}

export interface AggregateAccountAdminPromise
  extends Promise<AggregateAccountAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountAdminSubscription
  extends Promise<AsyncIterator<AggregateAccountAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AgeGroupConnection {
  pageInfo: PageInfo;
  edges: AgeGroupEdge[];
}

export interface AgeGroupConnectionPromise
  extends Promise<AgeGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgeGroupEdge>>() => T;
  aggregate: <T = AggregateAgeGroupPromise>() => T;
}

export interface AgeGroupConnectionSubscription
  extends Promise<AsyncIterator<AgeGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgeGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgeGroupSubscription>() => T;
}

export interface AgeGroupEdge {
  node: AgeGroup;
  cursor: String;
}

export interface AgeGroupEdgePromise
  extends Promise<AgeGroupEdge>,
    Fragmentable {
  node: <T = AgeGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgeGroupEdgeSubscription
  extends Promise<AsyncIterator<AgeGroupEdge>>,
    Fragmentable {
  node: <T = AgeGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAgeGroup {
  count: Int;
}

export interface AggregateAgeGroupPromise
  extends Promise<AggregateAgeGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgeGroupSubscription
  extends Promise<AsyncIterator<AggregateAgeGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassConnection {
  pageInfo: PageInfo;
  edges: ClassEdge[];
}

export interface ClassConnectionPromise
  extends Promise<ClassConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassEdge>>() => T;
  aggregate: <T = AggregateClassPromise>() => T;
}

export interface ClassConnectionSubscription
  extends Promise<AsyncIterator<ClassConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassSubscription>() => T;
}

export interface ClassEdge {
  node: Class;
  cursor: String;
}

export interface ClassEdgePromise extends Promise<ClassEdge>, Fragmentable {
  node: <T = ClassPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassEdgeSubscription
  extends Promise<AsyncIterator<ClassEdge>>,
    Fragmentable {
  node: <T = ClassSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClass {
  count: Int;
}

export interface AggregateClassPromise
  extends Promise<AggregateClass>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassSubscription
  extends Promise<AsyncIterator<AggregateClass>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FrontDesk {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  role: Role;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FrontDeskPromise extends Promise<FrontDesk>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  role: () => Promise<Role>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FrontDeskSubscription
  extends Promise<AsyncIterator<FrontDesk>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  role: () => Promise<AsyncIterator<Role>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FrontDeskNullablePromise
  extends Promise<FrontDesk | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  role: () => Promise<Role>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FrontDeskConnection {
  pageInfo: PageInfo;
  edges: FrontDeskEdge[];
}

export interface FrontDeskConnectionPromise
  extends Promise<FrontDeskConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FrontDeskEdge>>() => T;
  aggregate: <T = AggregateFrontDeskPromise>() => T;
}

export interface FrontDeskConnectionSubscription
  extends Promise<AsyncIterator<FrontDeskConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FrontDeskEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFrontDeskSubscription>() => T;
}

export interface FrontDeskEdge {
  node: FrontDesk;
  cursor: String;
}

export interface FrontDeskEdgePromise
  extends Promise<FrontDeskEdge>,
    Fragmentable {
  node: <T = FrontDeskPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FrontDeskEdgeSubscription
  extends Promise<AsyncIterator<FrontDeskEdge>>,
    Fragmentable {
  node: <T = FrontDeskSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFrontDesk {
  count: Int;
}

export interface AggregateFrontDeskPromise
  extends Promise<AggregateFrontDesk>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFrontDeskSubscription
  extends Promise<AsyncIterator<AggregateFrontDesk>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InstructorConnection {
  pageInfo: PageInfo;
  edges: InstructorEdge[];
}

export interface InstructorConnectionPromise
  extends Promise<InstructorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InstructorEdge>>() => T;
  aggregate: <T = AggregateInstructorPromise>() => T;
}

export interface InstructorConnectionSubscription
  extends Promise<AsyncIterator<InstructorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InstructorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInstructorSubscription>() => T;
}

export interface InstructorEdge {
  node: Instructor;
  cursor: String;
}

export interface InstructorEdgePromise
  extends Promise<InstructorEdge>,
    Fragmentable {
  node: <T = InstructorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InstructorEdgeSubscription
  extends Promise<AsyncIterator<InstructorEdge>>,
    Fragmentable {
  node: <T = InstructorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInstructor {
  count: Int;
}

export interface AggregateInstructorPromise
  extends Promise<AggregateInstructor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInstructorSubscription
  extends Promise<AsyncIterator<AggregateInstructor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LessonConnection {
  pageInfo: PageInfo;
  edges: LessonEdge[];
}

export interface LessonConnectionPromise
  extends Promise<LessonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LessonEdge>>() => T;
  aggregate: <T = AggregateLessonPromise>() => T;
}

export interface LessonConnectionSubscription
  extends Promise<AsyncIterator<LessonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LessonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLessonSubscription>() => T;
}

export interface LessonEdge {
  node: Lesson;
  cursor: String;
}

export interface LessonEdgePromise extends Promise<LessonEdge>, Fragmentable {
  node: <T = LessonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LessonEdgeSubscription
  extends Promise<AsyncIterator<LessonEdge>>,
    Fragmentable {
  node: <T = LessonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLesson {
  count: Int;
}

export interface AggregateLessonPromise
  extends Promise<AggregateLesson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLessonSubscription
  extends Promise<AsyncIterator<AggregateLesson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MedicalConditionConnection {
  pageInfo: PageInfo;
  edges: MedicalConditionEdge[];
}

export interface MedicalConditionConnectionPromise
  extends Promise<MedicalConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MedicalConditionEdge>>() => T;
  aggregate: <T = AggregateMedicalConditionPromise>() => T;
}

export interface MedicalConditionConnectionSubscription
  extends Promise<AsyncIterator<MedicalConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MedicalConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMedicalConditionSubscription>() => T;
}

export interface MedicalConditionEdge {
  node: MedicalCondition;
  cursor: String;
}

export interface MedicalConditionEdgePromise
  extends Promise<MedicalConditionEdge>,
    Fragmentable {
  node: <T = MedicalConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MedicalConditionEdgeSubscription
  extends Promise<AsyncIterator<MedicalConditionEdge>>,
    Fragmentable {
  node: <T = MedicalConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMedicalCondition {
  count: Int;
}

export interface AggregateMedicalConditionPromise
  extends Promise<AggregateMedicalCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMedicalConditionSubscription
  extends Promise<AsyncIterator<AggregateMedicalCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccountAdminSubscriptionPayload {
  mutation: MutationType;
  node: AccountAdmin;
  updatedFields: String[];
  previousValues: AccountAdminPreviousValues;
}

export interface AccountAdminSubscriptionPayloadPromise
  extends Promise<AccountAdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountAdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountAdminPreviousValuesPromise>() => T;
}

export interface AccountAdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountAdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountAdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountAdminPreviousValuesSubscription>() => T;
}

export interface AccountAdminPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AccountAdminPreviousValuesPromise
  extends Promise<AccountAdminPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountAdminPreviousValuesSubscription
  extends Promise<AsyncIterator<AccountAdminPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  stripeId: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AgeGroupSubscriptionPayload {
  mutation: MutationType;
  node: AgeGroup;
  updatedFields: String[];
  previousValues: AgeGroupPreviousValues;
}

export interface AgeGroupSubscriptionPayloadPromise
  extends Promise<AgeGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgeGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgeGroupPreviousValuesPromise>() => T;
}

export interface AgeGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgeGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgeGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgeGroupPreviousValuesSubscription>() => T;
}

export interface AgeGroupPreviousValues {
  id: ID_Output;
  minAge: Int;
  maxAge: Int;
  level?: SkillLevel;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AgeGroupPreviousValuesPromise
  extends Promise<AgeGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  level: () => Promise<SkillLevel>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<AgeGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  minAge: () => Promise<AsyncIterator<Int>>;
  maxAge: () => Promise<AsyncIterator<Int>>;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassSubscriptionPayload {
  mutation: MutationType;
  node: Class;
  updatedFields: String[];
  previousValues: ClassPreviousValues;
}

export interface ClassSubscriptionPayloadPromise
  extends Promise<ClassSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassPreviousValuesPromise>() => T;
}

export interface ClassSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassPreviousValuesSubscription>() => T;
}

export interface ClassPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  time: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPreviousValuesPromise
  extends Promise<ClassPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  duration: () => Promise<Int>;
  time: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  duration: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FrontDeskSubscriptionPayload {
  mutation: MutationType;
  node: FrontDesk;
  updatedFields: String[];
  previousValues: FrontDeskPreviousValues;
}

export interface FrontDeskSubscriptionPayloadPromise
  extends Promise<FrontDeskSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FrontDeskPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FrontDeskPreviousValuesPromise>() => T;
}

export interface FrontDeskSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FrontDeskSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FrontDeskSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FrontDeskPreviousValuesSubscription>() => T;
}

export interface FrontDeskPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  role: Role;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FrontDeskPreviousValuesPromise
  extends Promise<FrontDeskPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  role: () => Promise<Role>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FrontDeskPreviousValuesSubscription
  extends Promise<AsyncIterator<FrontDeskPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  role: () => Promise<AsyncIterator<Role>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InstructorSubscriptionPayload {
  mutation: MutationType;
  node: Instructor;
  updatedFields: String[];
  previousValues: InstructorPreviousValues;
}

export interface InstructorSubscriptionPayloadPromise
  extends Promise<InstructorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InstructorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InstructorPreviousValuesPromise>() => T;
}

export interface InstructorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InstructorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InstructorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InstructorPreviousValuesSubscription>() => T;
}

export interface InstructorPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InstructorPreviousValuesPromise
  extends Promise<InstructorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InstructorPreviousValuesSubscription
  extends Promise<AsyncIterator<InstructorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  bio: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LessonSubscriptionPayload {
  mutation: MutationType;
  node: Lesson;
  updatedFields: String[];
  previousValues: LessonPreviousValues;
}

export interface LessonSubscriptionPayloadPromise
  extends Promise<LessonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LessonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LessonPreviousValuesPromise>() => T;
}

export interface LessonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LessonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LessonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LessonPreviousValuesSubscription>() => T;
}

export interface LessonPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeOutput;
  open: Boolean;
}

export interface LessonPreviousValuesPromise
  extends Promise<LessonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  calendarColor: () => Promise<Color>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  time: () => Promise<DateTimeOutput>;
  open: () => Promise<Boolean>;
}

export interface LessonPreviousValuesSubscription
  extends Promise<AsyncIterator<LessonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  calendarColor: () => Promise<AsyncIterator<Color>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface MedicalConditionSubscriptionPayload {
  mutation: MutationType;
  node: MedicalCondition;
  updatedFields: String[];
  previousValues: MedicalConditionPreviousValues;
}

export interface MedicalConditionSubscriptionPayloadPromise
  extends Promise<MedicalConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MedicalConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MedicalConditionPreviousValuesPromise>() => T;
}

export interface MedicalConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MedicalConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MedicalConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MedicalConditionPreviousValuesSubscription>() => T;
}

export interface MedicalConditionPreviousValues {
  id: ID_Output;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicalConditionPreviousValuesPromise
  extends Promise<MedicalConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicalConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<MedicalConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  birthday: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  skill: SkillLevel;
  gender: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  skill: () => Promise<SkillLevel>;
  gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  skill: () => Promise<AsyncIterator<SkillLevel>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "SkillLevel",
    embedded: false
  },
  {
    name: "LessonType",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "Color",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "AccountAdmin",
    embedded: false
  },
  {
    name: "FrontDesk",
    embedded: false
  },
  {
    name: "Instructor",
    embedded: false
  },
  {
    name: "MedicalCondition",
    embedded: false
  },
  {
    name: "Class",
    embedded: false
  },
  {
    name: "Lesson",
    embedded: false
  },
  {
    name: "AgeGroup",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
