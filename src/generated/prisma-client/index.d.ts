// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  accountAdmin: (where?: AccountAdminWhereInput) => Promise<boolean>;
  ageGroup: (where?: AgeGroupWhereInput) => Promise<boolean>;
  class: (where?: ClassWhereInput) => Promise<boolean>;
  frontDesk: (where?: FrontDeskWhereInput) => Promise<boolean>;
  instructor: (where?: InstructorWhereInput) => Promise<boolean>;
  lesson: (where?: LessonWhereInput) => Promise<boolean>;
  medicalCondition: (where?: MedicalConditionWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  accountAdmin: (where: AccountAdminWhereUniqueInput) => AccountAdminPromise;
  accountAdmins: (args?: {
    where?: AccountAdminWhereInput;
    orderBy?: AccountAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AccountAdmin>;
  accountAdminsConnection: (args?: {
    where?: AccountAdminWhereInput;
    orderBy?: AccountAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccountAdminConnectionPromise;
  ageGroup: (where: AgeGroupWhereUniqueInput) => AgeGroupPromise;
  ageGroups: (args?: {
    where?: AgeGroupWhereInput;
    orderBy?: AgeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AgeGroup>;
  ageGroupsConnection: (args?: {
    where?: AgeGroupWhereInput;
    orderBy?: AgeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AgeGroupConnectionPromise;
  class: (where: ClassWhereUniqueInput) => ClassPromise;
  classes: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Class>;
  classesConnection: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassConnectionPromise;
  frontDesk: (where: FrontDeskWhereUniqueInput) => FrontDeskPromise;
  frontDesks: (args?: {
    where?: FrontDeskWhereInput;
    orderBy?: FrontDeskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FrontDesk>;
  frontDesksConnection: (args?: {
    where?: FrontDeskWhereInput;
    orderBy?: FrontDeskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FrontDeskConnectionPromise;
  instructor: (where: InstructorWhereUniqueInput) => InstructorPromise;
  instructors: (args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Instructor>;
  instructorsConnection: (args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InstructorConnectionPromise;
  lesson: (where: LessonWhereUniqueInput) => LessonPromise;
  lessons: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lesson>;
  lessonsConnection: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LessonConnectionPromise;
  medicalCondition: (
    where: MedicalConditionWhereUniqueInput
  ) => MedicalConditionPromise;
  medicalConditions: (args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MedicalCondition>;
  medicalConditionsConnection: (args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MedicalConditionConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentPromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccountAdmin: (data: AccountAdminCreateInput) => AccountAdminPromise;
  updateAccountAdmin: (args: {
    data: AccountAdminUpdateInput;
    where: AccountAdminWhereUniqueInput;
  }) => AccountAdminPromise;
  updateManyAccountAdmins: (args: {
    data: AccountAdminUpdateManyMutationInput;
    where?: AccountAdminWhereInput;
  }) => BatchPayloadPromise;
  upsertAccountAdmin: (args: {
    where: AccountAdminWhereUniqueInput;
    create: AccountAdminCreateInput;
    update: AccountAdminUpdateInput;
  }) => AccountAdminPromise;
  deleteAccountAdmin: (
    where: AccountAdminWhereUniqueInput
  ) => AccountAdminPromise;
  deleteManyAccountAdmins: (
    where?: AccountAdminWhereInput
  ) => BatchPayloadPromise;
  createAgeGroup: (data: AgeGroupCreateInput) => AgeGroupPromise;
  updateAgeGroup: (args: {
    data: AgeGroupUpdateInput;
    where: AgeGroupWhereUniqueInput;
  }) => AgeGroupPromise;
  updateManyAgeGroups: (args: {
    data: AgeGroupUpdateManyMutationInput;
    where?: AgeGroupWhereInput;
  }) => BatchPayloadPromise;
  upsertAgeGroup: (args: {
    where: AgeGroupWhereUniqueInput;
    create: AgeGroupCreateInput;
    update: AgeGroupUpdateInput;
  }) => AgeGroupPromise;
  deleteAgeGroup: (where: AgeGroupWhereUniqueInput) => AgeGroupPromise;
  deleteManyAgeGroups: (where?: AgeGroupWhereInput) => BatchPayloadPromise;
  createClass: (data: ClassCreateInput) => ClassPromise;
  updateClass: (args: {
    data: ClassUpdateInput;
    where: ClassWhereUniqueInput;
  }) => ClassPromise;
  updateManyClasses: (args: {
    data: ClassUpdateManyMutationInput;
    where?: ClassWhereInput;
  }) => BatchPayloadPromise;
  upsertClass: (args: {
    where: ClassWhereUniqueInput;
    create: ClassCreateInput;
    update: ClassUpdateInput;
  }) => ClassPromise;
  deleteClass: (where: ClassWhereUniqueInput) => ClassPromise;
  deleteManyClasses: (where?: ClassWhereInput) => BatchPayloadPromise;
  createFrontDesk: (data: FrontDeskCreateInput) => FrontDeskPromise;
  updateFrontDesk: (args: {
    data: FrontDeskUpdateInput;
    where: FrontDeskWhereUniqueInput;
  }) => FrontDeskPromise;
  updateManyFrontDesks: (args: {
    data: FrontDeskUpdateManyMutationInput;
    where?: FrontDeskWhereInput;
  }) => BatchPayloadPromise;
  upsertFrontDesk: (args: {
    where: FrontDeskWhereUniqueInput;
    create: FrontDeskCreateInput;
    update: FrontDeskUpdateInput;
  }) => FrontDeskPromise;
  deleteFrontDesk: (where: FrontDeskWhereUniqueInput) => FrontDeskPromise;
  deleteManyFrontDesks: (where?: FrontDeskWhereInput) => BatchPayloadPromise;
  createInstructor: (data: InstructorCreateInput) => InstructorPromise;
  updateInstructor: (args: {
    data: InstructorUpdateInput;
    where: InstructorWhereUniqueInput;
  }) => InstructorPromise;
  updateManyInstructors: (args: {
    data: InstructorUpdateManyMutationInput;
    where?: InstructorWhereInput;
  }) => BatchPayloadPromise;
  upsertInstructor: (args: {
    where: InstructorWhereUniqueInput;
    create: InstructorCreateInput;
    update: InstructorUpdateInput;
  }) => InstructorPromise;
  deleteInstructor: (where: InstructorWhereUniqueInput) => InstructorPromise;
  deleteManyInstructors: (where?: InstructorWhereInput) => BatchPayloadPromise;
  createLesson: (data: LessonCreateInput) => LessonPromise;
  updateLesson: (args: {
    data: LessonUpdateInput;
    where: LessonWhereUniqueInput;
  }) => LessonPromise;
  updateManyLessons: (args: {
    data: LessonUpdateManyMutationInput;
    where?: LessonWhereInput;
  }) => BatchPayloadPromise;
  upsertLesson: (args: {
    where: LessonWhereUniqueInput;
    create: LessonCreateInput;
    update: LessonUpdateInput;
  }) => LessonPromise;
  deleteLesson: (where: LessonWhereUniqueInput) => LessonPromise;
  deleteManyLessons: (where?: LessonWhereInput) => BatchPayloadPromise;
  createMedicalCondition: (
    data: MedicalConditionCreateInput
  ) => MedicalConditionPromise;
  updateMedicalCondition: (args: {
    data: MedicalConditionUpdateInput;
    where: MedicalConditionWhereUniqueInput;
  }) => MedicalConditionPromise;
  updateManyMedicalConditions: (args: {
    data: MedicalConditionUpdateManyMutationInput;
    where?: MedicalConditionWhereInput;
  }) => BatchPayloadPromise;
  upsertMedicalCondition: (args: {
    where: MedicalConditionWhereUniqueInput;
    create: MedicalConditionCreateInput;
    update: MedicalConditionUpdateInput;
  }) => MedicalConditionPromise;
  deleteMedicalCondition: (
    where: MedicalConditionWhereUniqueInput
  ) => MedicalConditionPromise;
  deleteManyMedicalConditions: (
    where?: MedicalConditionWhereInput
  ) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accountAdmin: (
    where?: AccountAdminSubscriptionWhereInput
  ) => AccountAdminSubscriptionPayloadSubscription;
  ageGroup: (
    where?: AgeGroupSubscriptionWhereInput
  ) => AgeGroupSubscriptionPayloadSubscription;
  class: (
    where?: ClassSubscriptionWhereInput
  ) => ClassSubscriptionPayloadSubscription;
  frontDesk: (
    where?: FrontDeskSubscriptionWhereInput
  ) => FrontDeskSubscriptionPayloadSubscription;
  instructor: (
    where?: InstructorSubscriptionWhereInput
  ) => InstructorSubscriptionPayloadSubscription;
  lesson: (
    where?: LessonSubscriptionWhereInput
  ) => LessonSubscriptionPayloadSubscription;
  medicalCondition: (
    where?: MedicalConditionSubscriptionWhereInput
  ) => MedicalConditionSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SkillLevel = "BEGINNER" | "INTERMEDIATE" | "ADVANCED";

export type Gender = "MALE" | "FEMALE";

export type Role = "ADMIN" | "INSTRUCTOR" | "FRONT_DESK";

export type Day =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY";

export type Color =
  | "RED"
  | "BLUE"
  | "BLACK"
  | "PURPLE"
  | "PINK"
  | "GREEN"
  | "ORANGE"
  | "GREY"
  | "YELLOW";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "skill_ASC"
  | "skill_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InstructorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "role_ASC"
  | "role_DESC"
  | "imageURL_ASC"
  | "imageURL_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "currentEmployee_ASC"
  | "currentEmployee_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClassOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "level_ASC"
  | "level_DESC"
  | "capacity_ASC"
  | "capacity_DESC"
  | "price_ASC"
  | "price_DESC"
  | "day_ASC"
  | "day_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "time_ASC"
  | "time_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LessonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "calendarColor_ASC"
  | "calendarColor_DESC"
  | "price_ASC"
  | "price_DESC"
  | "day_ASC"
  | "day_DESC"
  | "time_ASC"
  | "time_DESC"
  | "open_ASC"
  | "open_DESC";

export type MedicalConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AccountAdminOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "stripeId_ASC"
  | "stripeId_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AgeGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "minAge_ASC"
  | "minAge_DESC"
  | "maxAge_ASC"
  | "maxAge_DESC"
  | "level_ASC"
  | "level_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FrontDeskOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "role_ASC"
  | "role_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "currentEmployee_ASC"
  | "currentEmployee_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AccountAdminWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface StudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  birthday?: String;
  birthday_not?: String;
  birthday_in?: String[] | String;
  birthday_not_in?: String[] | String;
  birthday_lt?: String;
  birthday_lte?: String;
  birthday_gt?: String;
  birthday_gte?: String;
  birthday_contains?: String;
  birthday_not_contains?: String;
  birthday_starts_with?: String;
  birthday_not_starts_with?: String;
  birthday_ends_with?: String;
  birthday_not_ends_with?: String;
  skill?: SkillLevel;
  skill_not?: SkillLevel;
  skill_in?: SkillLevel[] | SkillLevel;
  skill_not_in?: SkillLevel[] | SkillLevel;
  ageGroup?: AgeGroupWhereInput;
  classes_every?: ClassWhereInput;
  classes_some?: ClassWhereInput;
  classes_none?: ClassWhereInput;
  lessons_every?: LessonWhereInput;
  lessons_some?: LessonWhereInput;
  lessons_none?: LessonWhereInput;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  medical_every?: MedicalConditionWhereInput;
  medical_some?: MedicalConditionWhereInput;
  medical_none?: MedicalConditionWhereInput;
  admin?: AccountAdminWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: StudentWhereInput[] | StudentWhereInput;
  OR?: StudentWhereInput[] | StudentWhereInput;
  NOT?: StudentWhereInput[] | StudentWhereInput;
}

export interface AgeGroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  minAge?: Int;
  minAge_not?: Int;
  minAge_in?: Int[] | Int;
  minAge_not_in?: Int[] | Int;
  minAge_lt?: Int;
  minAge_lte?: Int;
  minAge_gt?: Int;
  minAge_gte?: Int;
  maxAge?: Int;
  maxAge_not?: Int;
  maxAge_in?: Int[] | Int;
  maxAge_not_in?: Int[] | Int;
  maxAge_lt?: Int;
  maxAge_lte?: Int;
  maxAge_gt?: Int;
  maxAge_gte?: Int;
  level?: SkillLevel;
  level_not?: SkillLevel;
  level_in?: SkillLevel[] | SkillLevel;
  level_not_in?: SkillLevel[] | SkillLevel;
  instructors_every?: InstructorWhereInput;
  instructors_some?: InstructorWhereInput;
  instructors_none?: InstructorWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AgeGroupWhereInput[] | AgeGroupWhereInput;
  OR?: AgeGroupWhereInput[] | AgeGroupWhereInput;
  NOT?: AgeGroupWhereInput[] | AgeGroupWhereInput;
}

export interface InstructorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  zip?: Int;
  zip_not?: Int;
  zip_in?: Int[] | Int;
  zip_not_in?: Int[] | Int;
  zip_lt?: Int;
  zip_lte?: Int;
  zip_gt?: Int;
  zip_gte?: Int;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  imageURL?: String;
  imageURL_not?: String;
  imageURL_in?: String[] | String;
  imageURL_not_in?: String[] | String;
  imageURL_lt?: String;
  imageURL_lte?: String;
  imageURL_gt?: String;
  imageURL_gte?: String;
  imageURL_contains?: String;
  imageURL_not_contains?: String;
  imageURL_starts_with?: String;
  imageURL_not_starts_with?: String;
  imageURL_ends_with?: String;
  imageURL_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  currentEmployee?: Boolean;
  currentEmployee_not?: Boolean;
  clients_every?: StudentWhereInput;
  clients_some?: StudentWhereInput;
  clients_none?: StudentWhereInput;
  classes_every?: ClassWhereInput;
  classes_some?: ClassWhereInput;
  classes_none?: ClassWhereInput;
  lessons_every?: LessonWhereInput;
  lessons_some?: LessonWhereInput;
  lessons_none?: LessonWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: InstructorWhereInput[] | InstructorWhereInput;
  OR?: InstructorWhereInput[] | InstructorWhereInput;
  NOT?: InstructorWhereInput[] | InstructorWhereInput;
}

export interface ClassWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  ageGroup?: AgeGroupWhereInput;
  level?: SkillLevel;
  level_not?: SkillLevel;
  level_in?: SkillLevel[] | SkillLevel;
  level_not_in?: SkillLevel[] | SkillLevel;
  capacity?: Int;
  capacity_not?: Int;
  capacity_in?: Int[] | Int;
  capacity_not_in?: Int[] | Int;
  capacity_lt?: Int;
  capacity_lte?: Int;
  capacity_gt?: Int;
  capacity_gte?: Int;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  instructor?: InstructorWhereInput;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  students_every?: StudentWhereInput;
  students_some?: StudentWhereInput;
  students_none?: StudentWhereInput;
  time?: DateTimeInput;
  time_not?: DateTimeInput;
  time_in?: DateTimeInput[] | DateTimeInput;
  time_not_in?: DateTimeInput[] | DateTimeInput;
  time_lt?: DateTimeInput;
  time_lte?: DateTimeInput;
  time_gt?: DateTimeInput;
  time_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ClassWhereInput[] | ClassWhereInput;
  OR?: ClassWhereInput[] | ClassWhereInput;
  NOT?: ClassWhereInput[] | ClassWhereInput;
}

export interface LessonWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  instructor?: InstructorWhereInput;
  client_every?: StudentWhereInput;
  client_some?: StudentWhereInput;
  client_none?: StudentWhereInput;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  calendarColor?: Color;
  calendarColor_not?: Color;
  calendarColor_in?: Color[] | Color;
  calendarColor_not_in?: Color[] | Color;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  time?: DateTimeInput;
  time_not?: DateTimeInput;
  time_in?: DateTimeInput[] | DateTimeInput;
  time_not_in?: DateTimeInput[] | DateTimeInput;
  time_lt?: DateTimeInput;
  time_lte?: DateTimeInput;
  time_gt?: DateTimeInput;
  time_gte?: DateTimeInput;
  open?: Boolean;
  open_not?: Boolean;
  AND?: LessonWhereInput[] | LessonWhereInput;
  OR?: LessonWhereInput[] | LessonWhereInput;
  NOT?: LessonWhereInput[] | LessonWhereInput;
}

export interface MedicalConditionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  student_every?: StudentWhereInput;
  student_some?: StudentWhereInput;
  student_none?: StudentWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MedicalConditionWhereInput[] | MedicalConditionWhereInput;
  OR?: MedicalConditionWhereInput[] | MedicalConditionWhereInput;
  NOT?: MedicalConditionWhereInput[] | MedicalConditionWhereInput;
}

export interface AccountAdminWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  zip?: Int;
  zip_not?: Int;
  zip_in?: Int[] | Int;
  zip_not_in?: Int[] | Int;
  zip_lt?: Int;
  zip_lte?: Int;
  zip_gt?: Int;
  zip_gte?: Int;
  students_every?: StudentWhereInput;
  students_some?: StudentWhereInput;
  students_none?: StudentWhereInput;
  stripeId?: String;
  stripeId_not?: String;
  stripeId_in?: String[] | String;
  stripeId_not_in?: String[] | String;
  stripeId_lt?: String;
  stripeId_lte?: String;
  stripeId_gt?: String;
  stripeId_gte?: String;
  stripeId_contains?: String;
  stripeId_not_contains?: String;
  stripeId_starts_with?: String;
  stripeId_not_starts_with?: String;
  stripeId_ends_with?: String;
  stripeId_not_ends_with?: String;
  resetToken?: String;
  resetToken_not?: String;
  resetToken_in?: String[] | String;
  resetToken_not_in?: String[] | String;
  resetToken_lt?: String;
  resetToken_lte?: String;
  resetToken_gt?: String;
  resetToken_gte?: String;
  resetToken_contains?: String;
  resetToken_not_contains?: String;
  resetToken_starts_with?: String;
  resetToken_not_starts_with?: String;
  resetToken_ends_with?: String;
  resetToken_not_ends_with?: String;
  resetTokenExpiry?: String;
  resetTokenExpiry_not?: String;
  resetTokenExpiry_in?: String[] | String;
  resetTokenExpiry_not_in?: String[] | String;
  resetTokenExpiry_lt?: String;
  resetTokenExpiry_lte?: String;
  resetTokenExpiry_gt?: String;
  resetTokenExpiry_gte?: String;
  resetTokenExpiry_contains?: String;
  resetTokenExpiry_not_contains?: String;
  resetTokenExpiry_starts_with?: String;
  resetTokenExpiry_not_starts_with?: String;
  resetTokenExpiry_ends_with?: String;
  resetTokenExpiry_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AccountAdminWhereInput[] | AccountAdminWhereInput;
  OR?: AccountAdminWhereInput[] | AccountAdminWhereInput;
  NOT?: AccountAdminWhereInput[] | AccountAdminWhereInput;
}

export type AgeGroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ClassWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FrontDeskWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  phone?: String;
}>;

export interface FrontDeskWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  zip?: Int;
  zip_not?: Int;
  zip_in?: Int[] | Int;
  zip_not_in?: Int[] | Int;
  zip_lt?: Int;
  zip_lte?: Int;
  zip_gt?: Int;
  zip_gte?: Int;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  currentEmployee?: Boolean;
  currentEmployee_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FrontDeskWhereInput[] | FrontDeskWhereInput;
  OR?: FrontDeskWhereInput[] | FrontDeskWhereInput;
  NOT?: FrontDeskWhereInput[] | FrontDeskWhereInput;
}

export type InstructorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  phone?: String;
}>;

export type LessonWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MedicalConditionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type StudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AccountAdminCreateInput {
  id?: ID_Input;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  students?: StudentCreateManyWithoutAdminInput;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface StudentCreateManyWithoutAdminInput {
  create?: StudentCreateWithoutAdminInput[] | StudentCreateWithoutAdminInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutAdminInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: ClassCreateManyWithoutStudentsInput;
  lessons?: LessonCreateManyWithoutClientInput;
  gender: Gender;
  medical?: MedicalConditionCreateManyWithoutStudentInput;
}

export interface AgeGroupCreateOneInput {
  create?: AgeGroupCreateInput;
  connect?: AgeGroupWhereUniqueInput;
}

export interface AgeGroupCreateInput {
  id?: ID_Input;
  minAge: Int;
  maxAge: Int;
  level?: SkillLevel;
  instructors?: InstructorCreateManyInput;
}

export interface InstructorCreateManyInput {
  create?: InstructorCreateInput[] | InstructorCreateInput;
  connect?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
}

export interface InstructorCreateInput {
  id?: ID_Input;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee: Boolean;
  clients?: StudentCreateManyInput;
  classes?: ClassCreateManyWithoutInstructorInput;
  lessons?: LessonCreateManyWithoutInstructorInput;
}

export interface StudentCreateManyInput {
  create?: StudentCreateInput[] | StudentCreateInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: ClassCreateManyWithoutStudentsInput;
  lessons?: LessonCreateManyWithoutClientInput;
  gender: Gender;
  medical?: MedicalConditionCreateManyWithoutStudentInput;
  admin?: AccountAdminCreateOneWithoutStudentsInput;
}

export interface ClassCreateManyWithoutStudentsInput {
  create?: ClassCreateWithoutStudentsInput[] | ClassCreateWithoutStudentsInput;
  connect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
}

export interface ClassCreateWithoutStudentsInput {
  id?: ID_Input;
  name: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  instructor: InstructorCreateOneWithoutClassesInput;
  duration: Int;
  time: DateTimeInput;
}

export interface InstructorCreateOneWithoutClassesInput {
  create?: InstructorCreateWithoutClassesInput;
  connect?: InstructorWhereUniqueInput;
}

export interface InstructorCreateWithoutClassesInput {
  id?: ID_Input;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee: Boolean;
  clients?: StudentCreateManyInput;
  lessons?: LessonCreateManyWithoutInstructorInput;
}

export interface LessonCreateManyWithoutInstructorInput {
  create?:
    | LessonCreateWithoutInstructorInput[]
    | LessonCreateWithoutInstructorInput;
  connect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
}

export interface LessonCreateWithoutInstructorInput {
  id?: ID_Input;
  name: String;
  description: String;
  client?: StudentCreateManyWithoutLessonsInput;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeInput;
  open: Boolean;
}

export interface StudentCreateManyWithoutLessonsInput {
  create?:
    | StudentCreateWithoutLessonsInput[]
    | StudentCreateWithoutLessonsInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutLessonsInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: ClassCreateManyWithoutStudentsInput;
  gender: Gender;
  medical?: MedicalConditionCreateManyWithoutStudentInput;
  admin?: AccountAdminCreateOneWithoutStudentsInput;
}

export interface MedicalConditionCreateManyWithoutStudentInput {
  create?:
    | MedicalConditionCreateWithoutStudentInput[]
    | MedicalConditionCreateWithoutStudentInput;
  connect?:
    | MedicalConditionWhereUniqueInput[]
    | MedicalConditionWhereUniqueInput;
}

export interface MedicalConditionCreateWithoutStudentInput {
  id?: ID_Input;
  description: String;
}

export interface AccountAdminCreateOneWithoutStudentsInput {
  create?: AccountAdminCreateWithoutStudentsInput;
  connect?: AccountAdminWhereUniqueInput;
}

export interface AccountAdminCreateWithoutStudentsInput {
  id?: ID_Input;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface LessonCreateManyWithoutClientInput {
  create?: LessonCreateWithoutClientInput[] | LessonCreateWithoutClientInput;
  connect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
}

export interface LessonCreateWithoutClientInput {
  id?: ID_Input;
  name: String;
  description: String;
  instructor: InstructorCreateOneWithoutLessonsInput;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeInput;
  open: Boolean;
}

export interface InstructorCreateOneWithoutLessonsInput {
  create?: InstructorCreateWithoutLessonsInput;
  connect?: InstructorWhereUniqueInput;
}

export interface InstructorCreateWithoutLessonsInput {
  id?: ID_Input;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee: Boolean;
  clients?: StudentCreateManyInput;
  classes?: ClassCreateManyWithoutInstructorInput;
}

export interface ClassCreateManyWithoutInstructorInput {
  create?:
    | ClassCreateWithoutInstructorInput[]
    | ClassCreateWithoutInstructorInput;
  connect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
}

export interface ClassCreateWithoutInstructorInput {
  id?: ID_Input;
  name: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  students?: StudentCreateManyWithoutClassesInput;
  time: DateTimeInput;
}

export interface StudentCreateManyWithoutClassesInput {
  create?:
    | StudentCreateWithoutClassesInput[]
    | StudentCreateWithoutClassesInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutClassesInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  lessons?: LessonCreateManyWithoutClientInput;
  gender: Gender;
  medical?: MedicalConditionCreateManyWithoutStudentInput;
  admin?: AccountAdminCreateOneWithoutStudentsInput;
}

export interface AccountAdminUpdateInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  phone?: String;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  students?: StudentUpdateManyWithoutAdminInput;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface StudentUpdateManyWithoutAdminInput {
  create?: StudentCreateWithoutAdminInput[] | StudentCreateWithoutAdminInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutAdminInput[]
    | StudentUpdateWithWhereUniqueWithoutAdminInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutAdminInput[]
    | StudentUpsertWithWhereUniqueWithoutAdminInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutAdminInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutAdminDataInput;
}

export interface StudentUpdateWithoutAdminDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
}

export interface AgeGroupUpdateOneRequiredInput {
  create?: AgeGroupCreateInput;
  update?: AgeGroupUpdateDataInput;
  upsert?: AgeGroupUpsertNestedInput;
  connect?: AgeGroupWhereUniqueInput;
}

export interface AgeGroupUpdateDataInput {
  minAge?: Int;
  maxAge?: Int;
  level?: SkillLevel;
  instructors?: InstructorUpdateManyInput;
}

export interface InstructorUpdateManyInput {
  create?: InstructorCreateInput[] | InstructorCreateInput;
  update?:
    | InstructorUpdateWithWhereUniqueNestedInput[]
    | InstructorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | InstructorUpsertWithWhereUniqueNestedInput[]
    | InstructorUpsertWithWhereUniqueNestedInput;
  delete?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
  connect?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
  set?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
  disconnect?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
  deleteMany?: InstructorScalarWhereInput[] | InstructorScalarWhereInput;
  updateMany?:
    | InstructorUpdateManyWithWhereNestedInput[]
    | InstructorUpdateManyWithWhereNestedInput;
}

export interface InstructorUpdateWithWhereUniqueNestedInput {
  where: InstructorWhereUniqueInput;
  data: InstructorUpdateDataInput;
}

export interface InstructorUpdateDataInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: Role;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentUpdateManyInput;
  classes?: ClassUpdateManyWithoutInstructorInput;
  lessons?: LessonUpdateManyWithoutInstructorInput;
}

export interface StudentUpdateManyInput {
  create?: StudentCreateInput[] | StudentCreateInput;
  update?:
    | StudentUpdateWithWhereUniqueNestedInput[]
    | StudentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StudentUpsertWithWhereUniqueNestedInput[]
    | StudentUpsertWithWhereUniqueNestedInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateDataInput;
}

export interface StudentUpdateDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
  admin?: AccountAdminUpdateOneWithoutStudentsInput;
}

export interface ClassUpdateManyWithoutStudentsInput {
  create?: ClassCreateWithoutStudentsInput[] | ClassCreateWithoutStudentsInput;
  delete?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  connect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  set?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  disconnect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  update?:
    | ClassUpdateWithWhereUniqueWithoutStudentsInput[]
    | ClassUpdateWithWhereUniqueWithoutStudentsInput;
  upsert?:
    | ClassUpsertWithWhereUniqueWithoutStudentsInput[]
    | ClassUpsertWithWhereUniqueWithoutStudentsInput;
  deleteMany?: ClassScalarWhereInput[] | ClassScalarWhereInput;
  updateMany?:
    | ClassUpdateManyWithWhereNestedInput[]
    | ClassUpdateManyWithWhereNestedInput;
}

export interface ClassUpdateWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutStudentsDataInput;
}

export interface ClassUpdateWithoutStudentsDataInput {
  name?: String;
  description?: String;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  instructor?: InstructorUpdateOneRequiredWithoutClassesInput;
  duration?: Int;
  time?: DateTimeInput;
}

export interface InstructorUpdateOneRequiredWithoutClassesInput {
  create?: InstructorCreateWithoutClassesInput;
  update?: InstructorUpdateWithoutClassesDataInput;
  upsert?: InstructorUpsertWithoutClassesInput;
  connect?: InstructorWhereUniqueInput;
}

export interface InstructorUpdateWithoutClassesDataInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: Role;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentUpdateManyInput;
  lessons?: LessonUpdateManyWithoutInstructorInput;
}

export interface LessonUpdateManyWithoutInstructorInput {
  create?:
    | LessonCreateWithoutInstructorInput[]
    | LessonCreateWithoutInstructorInput;
  delete?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  connect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  set?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  disconnect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  update?:
    | LessonUpdateWithWhereUniqueWithoutInstructorInput[]
    | LessonUpdateWithWhereUniqueWithoutInstructorInput;
  upsert?:
    | LessonUpsertWithWhereUniqueWithoutInstructorInput[]
    | LessonUpsertWithWhereUniqueWithoutInstructorInput;
  deleteMany?: LessonScalarWhereInput[] | LessonScalarWhereInput;
  updateMany?:
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput;
}

export interface LessonUpdateWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutInstructorDataInput;
}

export interface LessonUpdateWithoutInstructorDataInput {
  name?: String;
  description?: String;
  client?: StudentUpdateManyWithoutLessonsInput;
  duration?: Int;
  calendarColor?: Color;
  price?: Int;
  day?: Day;
  time?: DateTimeInput;
  open?: Boolean;
}

export interface StudentUpdateManyWithoutLessonsInput {
  create?:
    | StudentCreateWithoutLessonsInput[]
    | StudentCreateWithoutLessonsInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutLessonsInput[]
    | StudentUpdateWithWhereUniqueWithoutLessonsInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutLessonsInput[]
    | StudentUpsertWithWhereUniqueWithoutLessonsInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutLessonsDataInput;
}

export interface StudentUpdateWithoutLessonsDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
  admin?: AccountAdminUpdateOneWithoutStudentsInput;
}

export interface MedicalConditionUpdateManyWithoutStudentInput {
  create?:
    | MedicalConditionCreateWithoutStudentInput[]
    | MedicalConditionCreateWithoutStudentInput;
  delete?:
    | MedicalConditionWhereUniqueInput[]
    | MedicalConditionWhereUniqueInput;
  connect?:
    | MedicalConditionWhereUniqueInput[]
    | MedicalConditionWhereUniqueInput;
  set?: MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput;
  disconnect?:
    | MedicalConditionWhereUniqueInput[]
    | MedicalConditionWhereUniqueInput;
  update?:
    | MedicalConditionUpdateWithWhereUniqueWithoutStudentInput[]
    | MedicalConditionUpdateWithWhereUniqueWithoutStudentInput;
  upsert?:
    | MedicalConditionUpsertWithWhereUniqueWithoutStudentInput[]
    | MedicalConditionUpsertWithWhereUniqueWithoutStudentInput;
  deleteMany?:
    | MedicalConditionScalarWhereInput[]
    | MedicalConditionScalarWhereInput;
  updateMany?:
    | MedicalConditionUpdateManyWithWhereNestedInput[]
    | MedicalConditionUpdateManyWithWhereNestedInput;
}

export interface MedicalConditionUpdateWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput;
  data: MedicalConditionUpdateWithoutStudentDataInput;
}

export interface MedicalConditionUpdateWithoutStudentDataInput {
  description?: String;
}

export interface MedicalConditionUpsertWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput;
  update: MedicalConditionUpdateWithoutStudentDataInput;
  create: MedicalConditionCreateWithoutStudentInput;
}

export interface MedicalConditionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput;
  OR?: MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput;
  NOT?: MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput;
}

export interface MedicalConditionUpdateManyWithWhereNestedInput {
  where: MedicalConditionScalarWhereInput;
  data: MedicalConditionUpdateManyDataInput;
}

export interface MedicalConditionUpdateManyDataInput {
  description?: String;
}

export interface AccountAdminUpdateOneWithoutStudentsInput {
  create?: AccountAdminCreateWithoutStudentsInput;
  update?: AccountAdminUpdateWithoutStudentsDataInput;
  upsert?: AccountAdminUpsertWithoutStudentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AccountAdminWhereUniqueInput;
}

export interface AccountAdminUpdateWithoutStudentsDataInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  phone?: String;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface AccountAdminUpsertWithoutStudentsInput {
  update: AccountAdminUpdateWithoutStudentsDataInput;
  create: AccountAdminCreateWithoutStudentsInput;
}

export interface StudentUpsertWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutLessonsDataInput;
  create: StudentCreateWithoutLessonsInput;
}

export interface StudentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  birthday?: String;
  birthday_not?: String;
  birthday_in?: String[] | String;
  birthday_not_in?: String[] | String;
  birthday_lt?: String;
  birthday_lte?: String;
  birthday_gt?: String;
  birthday_gte?: String;
  birthday_contains?: String;
  birthday_not_contains?: String;
  birthday_starts_with?: String;
  birthday_not_starts_with?: String;
  birthday_ends_with?: String;
  birthday_not_ends_with?: String;
  skill?: SkillLevel;
  skill_not?: SkillLevel;
  skill_in?: SkillLevel[] | SkillLevel;
  skill_not_in?: SkillLevel[] | SkillLevel;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  OR?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  NOT?: StudentScalarWhereInput[] | StudentScalarWhereInput;
}

export interface StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput;
  data: StudentUpdateManyDataInput;
}

export interface StudentUpdateManyDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  gender?: Gender;
}

export interface LessonUpsertWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutInstructorDataInput;
  create: LessonCreateWithoutInstructorInput;
}

export interface LessonScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  calendarColor?: Color;
  calendarColor_not?: Color;
  calendarColor_in?: Color[] | Color;
  calendarColor_not_in?: Color[] | Color;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  time?: DateTimeInput;
  time_not?: DateTimeInput;
  time_in?: DateTimeInput[] | DateTimeInput;
  time_not_in?: DateTimeInput[] | DateTimeInput;
  time_lt?: DateTimeInput;
  time_lte?: DateTimeInput;
  time_gt?: DateTimeInput;
  time_gte?: DateTimeInput;
  open?: Boolean;
  open_not?: Boolean;
  AND?: LessonScalarWhereInput[] | LessonScalarWhereInput;
  OR?: LessonScalarWhereInput[] | LessonScalarWhereInput;
  NOT?: LessonScalarWhereInput[] | LessonScalarWhereInput;
}

export interface LessonUpdateManyWithWhereNestedInput {
  where: LessonScalarWhereInput;
  data: LessonUpdateManyDataInput;
}

export interface LessonUpdateManyDataInput {
  name?: String;
  description?: String;
  duration?: Int;
  calendarColor?: Color;
  price?: Int;
  day?: Day;
  time?: DateTimeInput;
  open?: Boolean;
}

export interface InstructorUpsertWithoutClassesInput {
  update: InstructorUpdateWithoutClassesDataInput;
  create: InstructorCreateWithoutClassesInput;
}

export interface ClassUpsertWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutStudentsDataInput;
  create: ClassCreateWithoutStudentsInput;
}

export interface ClassScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  level?: SkillLevel;
  level_not?: SkillLevel;
  level_in?: SkillLevel[] | SkillLevel;
  level_not_in?: SkillLevel[] | SkillLevel;
  capacity?: Int;
  capacity_not?: Int;
  capacity_in?: Int[] | Int;
  capacity_not_in?: Int[] | Int;
  capacity_lt?: Int;
  capacity_lte?: Int;
  capacity_gt?: Int;
  capacity_gte?: Int;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  time?: DateTimeInput;
  time_not?: DateTimeInput;
  time_in?: DateTimeInput[] | DateTimeInput;
  time_not_in?: DateTimeInput[] | DateTimeInput;
  time_lt?: DateTimeInput;
  time_lte?: DateTimeInput;
  time_gt?: DateTimeInput;
  time_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ClassScalarWhereInput[] | ClassScalarWhereInput;
  OR?: ClassScalarWhereInput[] | ClassScalarWhereInput;
  NOT?: ClassScalarWhereInput[] | ClassScalarWhereInput;
}

export interface ClassUpdateManyWithWhereNestedInput {
  where: ClassScalarWhereInput;
  data: ClassUpdateManyDataInput;
}

export interface ClassUpdateManyDataInput {
  name?: String;
  description?: String;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  duration?: Int;
  time?: DateTimeInput;
}

export interface LessonUpdateManyWithoutClientInput {
  create?: LessonCreateWithoutClientInput[] | LessonCreateWithoutClientInput;
  delete?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  connect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  set?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  disconnect?: LessonWhereUniqueInput[] | LessonWhereUniqueInput;
  update?:
    | LessonUpdateWithWhereUniqueWithoutClientInput[]
    | LessonUpdateWithWhereUniqueWithoutClientInput;
  upsert?:
    | LessonUpsertWithWhereUniqueWithoutClientInput[]
    | LessonUpsertWithWhereUniqueWithoutClientInput;
  deleteMany?: LessonScalarWhereInput[] | LessonScalarWhereInput;
  updateMany?:
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput;
}

export interface LessonUpdateWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutClientDataInput;
}

export interface LessonUpdateWithoutClientDataInput {
  name?: String;
  description?: String;
  instructor?: InstructorUpdateOneRequiredWithoutLessonsInput;
  duration?: Int;
  calendarColor?: Color;
  price?: Int;
  day?: Day;
  time?: DateTimeInput;
  open?: Boolean;
}

export interface InstructorUpdateOneRequiredWithoutLessonsInput {
  create?: InstructorCreateWithoutLessonsInput;
  update?: InstructorUpdateWithoutLessonsDataInput;
  upsert?: InstructorUpsertWithoutLessonsInput;
  connect?: InstructorWhereUniqueInput;
}

export interface InstructorUpdateWithoutLessonsDataInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: Role;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentUpdateManyInput;
  classes?: ClassUpdateManyWithoutInstructorInput;
}

export interface ClassUpdateManyWithoutInstructorInput {
  create?:
    | ClassCreateWithoutInstructorInput[]
    | ClassCreateWithoutInstructorInput;
  delete?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  connect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  set?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  disconnect?: ClassWhereUniqueInput[] | ClassWhereUniqueInput;
  update?:
    | ClassUpdateWithWhereUniqueWithoutInstructorInput[]
    | ClassUpdateWithWhereUniqueWithoutInstructorInput;
  upsert?:
    | ClassUpsertWithWhereUniqueWithoutInstructorInput[]
    | ClassUpsertWithWhereUniqueWithoutInstructorInput;
  deleteMany?: ClassScalarWhereInput[] | ClassScalarWhereInput;
  updateMany?:
    | ClassUpdateManyWithWhereNestedInput[]
    | ClassUpdateManyWithWhereNestedInput;
}

export interface ClassUpdateWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutInstructorDataInput;
}

export interface ClassUpdateWithoutInstructorDataInput {
  name?: String;
  description?: String;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  duration?: Int;
  students?: StudentUpdateManyWithoutClassesInput;
  time?: DateTimeInput;
}

export interface StudentUpdateManyWithoutClassesInput {
  create?:
    | StudentCreateWithoutClassesInput[]
    | StudentCreateWithoutClassesInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutClassesInput[]
    | StudentUpdateWithWhereUniqueWithoutClassesInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutClassesInput[]
    | StudentUpsertWithWhereUniqueWithoutClassesInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutClassesDataInput;
}

export interface StudentUpdateWithoutClassesDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
  admin?: AccountAdminUpdateOneWithoutStudentsInput;
}

export interface StudentUpsertWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutClassesDataInput;
  create: StudentCreateWithoutClassesInput;
}

export interface ClassUpsertWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutInstructorDataInput;
  create: ClassCreateWithoutInstructorInput;
}

export interface InstructorUpsertWithoutLessonsInput {
  update: InstructorUpdateWithoutLessonsDataInput;
  create: InstructorCreateWithoutLessonsInput;
}

export interface LessonUpsertWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutClientDataInput;
  create: LessonCreateWithoutClientInput;
}

export interface StudentUpsertWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateDataInput;
  create: StudentCreateInput;
}

export interface InstructorUpsertWithWhereUniqueNestedInput {
  where: InstructorWhereUniqueInput;
  update: InstructorUpdateDataInput;
  create: InstructorCreateInput;
}

export interface InstructorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  zip?: Int;
  zip_not?: Int;
  zip_in?: Int[] | Int;
  zip_not_in?: Int[] | Int;
  zip_lt?: Int;
  zip_lte?: Int;
  zip_gt?: Int;
  zip_gte?: Int;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  imageURL?: String;
  imageURL_not?: String;
  imageURL_in?: String[] | String;
  imageURL_not_in?: String[] | String;
  imageURL_lt?: String;
  imageURL_lte?: String;
  imageURL_gt?: String;
  imageURL_gte?: String;
  imageURL_contains?: String;
  imageURL_not_contains?: String;
  imageURL_starts_with?: String;
  imageURL_not_starts_with?: String;
  imageURL_ends_with?: String;
  imageURL_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  currentEmployee?: Boolean;
  currentEmployee_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: InstructorScalarWhereInput[] | InstructorScalarWhereInput;
  OR?: InstructorScalarWhereInput[] | InstructorScalarWhereInput;
  NOT?: InstructorScalarWhereInput[] | InstructorScalarWhereInput;
}

export interface InstructorUpdateManyWithWhereNestedInput {
  where: InstructorScalarWhereInput;
  data: InstructorUpdateManyDataInput;
}

export interface InstructorUpdateManyDataInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: Role;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
}

export interface AgeGroupUpsertNestedInput {
  update: AgeGroupUpdateDataInput;
  create: AgeGroupCreateInput;
}

export interface StudentUpsertWithWhereUniqueWithoutAdminInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutAdminDataInput;
  create: StudentCreateWithoutAdminInput;
}

export interface AccountAdminUpdateManyMutationInput {
  email?: String;
  password?: String;
  firstName?: String;
  lastName?: String;
  phone?: String;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
}

export interface AgeGroupUpdateInput {
  minAge?: Int;
  maxAge?: Int;
  level?: SkillLevel;
  instructors?: InstructorUpdateManyInput;
}

export interface AgeGroupUpdateManyMutationInput {
  minAge?: Int;
  maxAge?: Int;
  level?: SkillLevel;
}

export interface ClassCreateInput {
  id?: ID_Input;
  name: String;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  instructor: InstructorCreateOneWithoutClassesInput;
  duration: Int;
  students?: StudentCreateManyWithoutClassesInput;
  time: DateTimeInput;
}

export interface ClassUpdateInput {
  name?: String;
  description?: String;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  instructor?: InstructorUpdateOneRequiredWithoutClassesInput;
  duration?: Int;
  students?: StudentUpdateManyWithoutClassesInput;
  time?: DateTimeInput;
}

export interface ClassUpdateManyMutationInput {
  name?: String;
  description?: String;
  level?: SkillLevel;
  capacity?: Int;
  price?: Int;
  day?: Day;
  duration?: Int;
  time?: DateTimeInput;
}

export interface FrontDeskCreateInput {
  id?: ID_Input;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  role: Role;
  startDate: DateTimeInput;
  currentEmployee: Boolean;
}

export interface FrontDeskUpdateInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  role?: Role;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
}

export interface FrontDeskUpdateManyMutationInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  role?: Role;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
}

export interface InstructorUpdateInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: Role;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
  clients?: StudentUpdateManyInput;
  classes?: ClassUpdateManyWithoutInstructorInput;
  lessons?: LessonUpdateManyWithoutInstructorInput;
}

export interface InstructorUpdateManyMutationInput {
  email?: String;
  password?: String;
  phone?: String;
  firstName?: String;
  lastName?: String;
  gender?: Gender;
  address?: String;
  city?: String;
  state?: String;
  zip?: Int;
  bio?: String;
  role?: Role;
  imageURL?: String;
  startDate?: DateTimeInput;
  currentEmployee?: Boolean;
}

export interface LessonCreateInput {
  id?: ID_Input;
  name: String;
  description: String;
  instructor: InstructorCreateOneWithoutLessonsInput;
  client?: StudentCreateManyWithoutLessonsInput;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeInput;
  open: Boolean;
}

export interface LessonUpdateInput {
  name?: String;
  description?: String;
  instructor?: InstructorUpdateOneRequiredWithoutLessonsInput;
  client?: StudentUpdateManyWithoutLessonsInput;
  duration?: Int;
  calendarColor?: Color;
  price?: Int;
  day?: Day;
  time?: DateTimeInput;
  open?: Boolean;
}

export interface LessonUpdateManyMutationInput {
  name?: String;
  description?: String;
  duration?: Int;
  calendarColor?: Color;
  price?: Int;
  day?: Day;
  time?: DateTimeInput;
  open?: Boolean;
}

export interface MedicalConditionCreateInput {
  id?: ID_Input;
  description: String;
  student?: StudentCreateManyWithoutMedicalInput;
}

export interface StudentCreateManyWithoutMedicalInput {
  create?:
    | StudentCreateWithoutMedicalInput[]
    | StudentCreateWithoutMedicalInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutMedicalInput {
  id?: ID_Input;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: ClassCreateManyWithoutStudentsInput;
  lessons?: LessonCreateManyWithoutClientInput;
  gender: Gender;
  admin?: AccountAdminCreateOneWithoutStudentsInput;
}

export interface MedicalConditionUpdateInput {
  description?: String;
  student?: StudentUpdateManyWithoutMedicalInput;
}

export interface StudentUpdateManyWithoutMedicalInput {
  create?:
    | StudentCreateWithoutMedicalInput[]
    | StudentCreateWithoutMedicalInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  set?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutMedicalInput[]
    | StudentUpdateWithWhereUniqueWithoutMedicalInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutMedicalInput[]
    | StudentUpsertWithWhereUniqueWithoutMedicalInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutMedicalInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutMedicalDataInput;
}

export interface StudentUpdateWithoutMedicalDataInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  admin?: AccountAdminUpdateOneWithoutStudentsInput;
}

export interface StudentUpsertWithWhereUniqueWithoutMedicalInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutMedicalDataInput;
  create: StudentCreateWithoutMedicalInput;
}

export interface MedicalConditionUpdateManyMutationInput {
  description?: String;
}

export interface StudentUpdateInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  ageGroup?: AgeGroupUpdateOneRequiredInput;
  classes?: ClassUpdateManyWithoutStudentsInput;
  lessons?: LessonUpdateManyWithoutClientInput;
  gender?: Gender;
  medical?: MedicalConditionUpdateManyWithoutStudentInput;
  admin?: AccountAdminUpdateOneWithoutStudentsInput;
}

export interface StudentUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  birthday?: String;
  skill?: SkillLevel;
  gender?: Gender;
}

export interface AccountAdminSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccountAdminWhereInput;
  AND?:
    | AccountAdminSubscriptionWhereInput[]
    | AccountAdminSubscriptionWhereInput;
  OR?:
    | AccountAdminSubscriptionWhereInput[]
    | AccountAdminSubscriptionWhereInput;
  NOT?:
    | AccountAdminSubscriptionWhereInput[]
    | AccountAdminSubscriptionWhereInput;
}

export interface AgeGroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AgeGroupWhereInput;
  AND?: AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput;
  OR?: AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput;
  NOT?: AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput;
}

export interface ClassSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClassWhereInput;
  AND?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
  OR?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
  NOT?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
}

export interface FrontDeskSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FrontDeskWhereInput;
  AND?: FrontDeskSubscriptionWhereInput[] | FrontDeskSubscriptionWhereInput;
  OR?: FrontDeskSubscriptionWhereInput[] | FrontDeskSubscriptionWhereInput;
  NOT?: FrontDeskSubscriptionWhereInput[] | FrontDeskSubscriptionWhereInput;
}

export interface InstructorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InstructorWhereInput;
  AND?: InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput;
  OR?: InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput;
  NOT?: InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput;
}

export interface LessonSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LessonWhereInput;
  AND?: LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput;
  OR?: LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput;
  NOT?: LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput;
}

export interface MedicalConditionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MedicalConditionWhereInput;
  AND?:
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput;
  OR?:
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput;
  NOT?:
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentWhereInput;
  AND?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  OR?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  NOT?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AccountAdmin {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AccountAdminPromise
  extends Promise<AccountAdmin>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountAdminSubscription
  extends Promise<AsyncIterator<AccountAdmin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  students: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Student {
  id: ID_Output;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  gender: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  skill: () => Promise<SkillLevel>;
  ageGroup: <T = AgeGroupPromise>() => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<Gender>;
  medical: <T = FragmentableArray<MedicalCondition>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admin: <T = AccountAdminPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  skill: () => Promise<AsyncIterator<SkillLevel>>;
  ageGroup: <T = AgeGroupSubscription>() => T;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<AsyncIterator<Gender>>;
  medical: <T = Promise<AsyncIterator<MedicalConditionSubscription>>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admin: <T = AccountAdminSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AgeGroup {
  id: ID_Output;
  minAge: Int;
  maxAge: Int;
  level?: SkillLevel;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AgeGroupPromise extends Promise<AgeGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  level: () => Promise<SkillLevel>;
  instructors: <T = FragmentableArray<Instructor>>(args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupSubscription
  extends Promise<AsyncIterator<AgeGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  minAge: () => Promise<AsyncIterator<Int>>;
  maxAge: () => Promise<AsyncIterator<Int>>;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  instructors: <T = Promise<AsyncIterator<InstructorSubscription>>>(args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Instructor {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InstructorPromise extends Promise<Instructor>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  clients: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InstructorSubscription
  extends Promise<AsyncIterator<Instructor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  bio: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  clients: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Class {
  id: ID_Output;
  name: String;
  description: String;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  time: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPromise extends Promise<Class>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  ageGroup: <T = AgeGroupPromise>() => T;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  instructor: <T = InstructorPromise>() => T;
  duration: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassSubscription
  extends Promise<AsyncIterator<Class>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  ageGroup: <T = AgeGroupSubscription>() => T;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  instructor: <T = InstructorSubscription>() => T;
  duration: () => Promise<AsyncIterator<Int>>;
  students: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Lesson {
  id: ID_Output;
  name: String;
  description: String;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeOutput;
  open: Boolean;
}

export interface LessonPromise extends Promise<Lesson>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  instructor: <T = InstructorPromise>() => T;
  client: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Int>;
  calendarColor: () => Promise<Color>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  time: () => Promise<DateTimeOutput>;
  open: () => Promise<Boolean>;
}

export interface LessonSubscription
  extends Promise<AsyncIterator<Lesson>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  instructor: <T = InstructorSubscription>() => T;
  client: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<AsyncIterator<Int>>;
  calendarColor: () => Promise<AsyncIterator<Color>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface MedicalCondition {
  id: ID_Output;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicalConditionPromise
  extends Promise<MedicalCondition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  student: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicalConditionSubscription
  extends Promise<AsyncIterator<MedicalCondition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  student: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AccountAdminConnection {
  pageInfo: PageInfo;
  edges: AccountAdminEdge[];
}

export interface AccountAdminConnectionPromise
  extends Promise<AccountAdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountAdminEdge>>() => T;
  aggregate: <T = AggregateAccountAdminPromise>() => T;
}

export interface AccountAdminConnectionSubscription
  extends Promise<AsyncIterator<AccountAdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccountAdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccountAdminSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountAdminEdge {
  node: AccountAdmin;
  cursor: String;
}

export interface AccountAdminEdgePromise
  extends Promise<AccountAdminEdge>,
    Fragmentable {
  node: <T = AccountAdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountAdminEdgeSubscription
  extends Promise<AsyncIterator<AccountAdminEdge>>,
    Fragmentable {
  node: <T = AccountAdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccountAdmin {
  count: Int;
}

export interface AggregateAccountAdminPromise
  extends Promise<AggregateAccountAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountAdminSubscription
  extends Promise<AsyncIterator<AggregateAccountAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AgeGroupConnection {
  pageInfo: PageInfo;
  edges: AgeGroupEdge[];
}

export interface AgeGroupConnectionPromise
  extends Promise<AgeGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgeGroupEdge>>() => T;
  aggregate: <T = AggregateAgeGroupPromise>() => T;
}

export interface AgeGroupConnectionSubscription
  extends Promise<AsyncIterator<AgeGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgeGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgeGroupSubscription>() => T;
}

export interface AgeGroupEdge {
  node: AgeGroup;
  cursor: String;
}

export interface AgeGroupEdgePromise
  extends Promise<AgeGroupEdge>,
    Fragmentable {
  node: <T = AgeGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgeGroupEdgeSubscription
  extends Promise<AsyncIterator<AgeGroupEdge>>,
    Fragmentable {
  node: <T = AgeGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAgeGroup {
  count: Int;
}

export interface AggregateAgeGroupPromise
  extends Promise<AggregateAgeGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgeGroupSubscription
  extends Promise<AsyncIterator<AggregateAgeGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassConnection {
  pageInfo: PageInfo;
  edges: ClassEdge[];
}

export interface ClassConnectionPromise
  extends Promise<ClassConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassEdge>>() => T;
  aggregate: <T = AggregateClassPromise>() => T;
}

export interface ClassConnectionSubscription
  extends Promise<AsyncIterator<ClassConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassSubscription>() => T;
}

export interface ClassEdge {
  node: Class;
  cursor: String;
}

export interface ClassEdgePromise extends Promise<ClassEdge>, Fragmentable {
  node: <T = ClassPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassEdgeSubscription
  extends Promise<AsyncIterator<ClassEdge>>,
    Fragmentable {
  node: <T = ClassSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClass {
  count: Int;
}

export interface AggregateClassPromise
  extends Promise<AggregateClass>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassSubscription
  extends Promise<AsyncIterator<AggregateClass>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FrontDesk {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  role: Role;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FrontDeskPromise extends Promise<FrontDesk>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  role: () => Promise<Role>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FrontDeskSubscription
  extends Promise<AsyncIterator<FrontDesk>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  role: () => Promise<AsyncIterator<Role>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FrontDeskConnection {
  pageInfo: PageInfo;
  edges: FrontDeskEdge[];
}

export interface FrontDeskConnectionPromise
  extends Promise<FrontDeskConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FrontDeskEdge>>() => T;
  aggregate: <T = AggregateFrontDeskPromise>() => T;
}

export interface FrontDeskConnectionSubscription
  extends Promise<AsyncIterator<FrontDeskConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FrontDeskEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFrontDeskSubscription>() => T;
}

export interface FrontDeskEdge {
  node: FrontDesk;
  cursor: String;
}

export interface FrontDeskEdgePromise
  extends Promise<FrontDeskEdge>,
    Fragmentable {
  node: <T = FrontDeskPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FrontDeskEdgeSubscription
  extends Promise<AsyncIterator<FrontDeskEdge>>,
    Fragmentable {
  node: <T = FrontDeskSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFrontDesk {
  count: Int;
}

export interface AggregateFrontDeskPromise
  extends Promise<AggregateFrontDesk>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFrontDeskSubscription
  extends Promise<AsyncIterator<AggregateFrontDesk>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InstructorConnection {
  pageInfo: PageInfo;
  edges: InstructorEdge[];
}

export interface InstructorConnectionPromise
  extends Promise<InstructorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InstructorEdge>>() => T;
  aggregate: <T = AggregateInstructorPromise>() => T;
}

export interface InstructorConnectionSubscription
  extends Promise<AsyncIterator<InstructorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InstructorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInstructorSubscription>() => T;
}

export interface InstructorEdge {
  node: Instructor;
  cursor: String;
}

export interface InstructorEdgePromise
  extends Promise<InstructorEdge>,
    Fragmentable {
  node: <T = InstructorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InstructorEdgeSubscription
  extends Promise<AsyncIterator<InstructorEdge>>,
    Fragmentable {
  node: <T = InstructorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInstructor {
  count: Int;
}

export interface AggregateInstructorPromise
  extends Promise<AggregateInstructor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInstructorSubscription
  extends Promise<AsyncIterator<AggregateInstructor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LessonConnection {
  pageInfo: PageInfo;
  edges: LessonEdge[];
}

export interface LessonConnectionPromise
  extends Promise<LessonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LessonEdge>>() => T;
  aggregate: <T = AggregateLessonPromise>() => T;
}

export interface LessonConnectionSubscription
  extends Promise<AsyncIterator<LessonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LessonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLessonSubscription>() => T;
}

export interface LessonEdge {
  node: Lesson;
  cursor: String;
}

export interface LessonEdgePromise extends Promise<LessonEdge>, Fragmentable {
  node: <T = LessonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LessonEdgeSubscription
  extends Promise<AsyncIterator<LessonEdge>>,
    Fragmentable {
  node: <T = LessonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLesson {
  count: Int;
}

export interface AggregateLessonPromise
  extends Promise<AggregateLesson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLessonSubscription
  extends Promise<AsyncIterator<AggregateLesson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MedicalConditionConnection {
  pageInfo: PageInfo;
  edges: MedicalConditionEdge[];
}

export interface MedicalConditionConnectionPromise
  extends Promise<MedicalConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MedicalConditionEdge>>() => T;
  aggregate: <T = AggregateMedicalConditionPromise>() => T;
}

export interface MedicalConditionConnectionSubscription
  extends Promise<AsyncIterator<MedicalConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MedicalConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMedicalConditionSubscription>() => T;
}

export interface MedicalConditionEdge {
  node: MedicalCondition;
  cursor: String;
}

export interface MedicalConditionEdgePromise
  extends Promise<MedicalConditionEdge>,
    Fragmentable {
  node: <T = MedicalConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MedicalConditionEdgeSubscription
  extends Promise<AsyncIterator<MedicalConditionEdge>>,
    Fragmentable {
  node: <T = MedicalConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMedicalCondition {
  count: Int;
}

export interface AggregateMedicalConditionPromise
  extends Promise<AggregateMedicalCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMedicalConditionSubscription
  extends Promise<AsyncIterator<AggregateMedicalCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccountAdminSubscriptionPayload {
  mutation: MutationType;
  node: AccountAdmin;
  updatedFields: String[];
  previousValues: AccountAdminPreviousValues;
}

export interface AccountAdminSubscriptionPayloadPromise
  extends Promise<AccountAdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountAdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountAdminPreviousValuesPromise>() => T;
}

export interface AccountAdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountAdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountAdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountAdminPreviousValuesSubscription>() => T;
}

export interface AccountAdminPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AccountAdminPreviousValuesPromise
  extends Promise<AccountAdminPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountAdminPreviousValuesSubscription
  extends Promise<AsyncIterator<AccountAdminPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  stripeId: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AgeGroupSubscriptionPayload {
  mutation: MutationType;
  node: AgeGroup;
  updatedFields: String[];
  previousValues: AgeGroupPreviousValues;
}

export interface AgeGroupSubscriptionPayloadPromise
  extends Promise<AgeGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgeGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgeGroupPreviousValuesPromise>() => T;
}

export interface AgeGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgeGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgeGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgeGroupPreviousValuesSubscription>() => T;
}

export interface AgeGroupPreviousValues {
  id: ID_Output;
  minAge: Int;
  maxAge: Int;
  level?: SkillLevel;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AgeGroupPreviousValuesPromise
  extends Promise<AgeGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  level: () => Promise<SkillLevel>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<AgeGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  minAge: () => Promise<AsyncIterator<Int>>;
  maxAge: () => Promise<AsyncIterator<Int>>;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassSubscriptionPayload {
  mutation: MutationType;
  node: Class;
  updatedFields: String[];
  previousValues: ClassPreviousValues;
}

export interface ClassSubscriptionPayloadPromise
  extends Promise<ClassSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassPreviousValuesPromise>() => T;
}

export interface ClassSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassPreviousValuesSubscription>() => T;
}

export interface ClassPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  time: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPreviousValuesPromise
  extends Promise<ClassPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  duration: () => Promise<Int>;
  time: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  duration: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FrontDeskSubscriptionPayload {
  mutation: MutationType;
  node: FrontDesk;
  updatedFields: String[];
  previousValues: FrontDeskPreviousValues;
}

export interface FrontDeskSubscriptionPayloadPromise
  extends Promise<FrontDeskSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FrontDeskPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FrontDeskPreviousValuesPromise>() => T;
}

export interface FrontDeskSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FrontDeskSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FrontDeskSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FrontDeskPreviousValuesSubscription>() => T;
}

export interface FrontDeskPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  role: Role;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FrontDeskPreviousValuesPromise
  extends Promise<FrontDeskPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  role: () => Promise<Role>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FrontDeskPreviousValuesSubscription
  extends Promise<AsyncIterator<FrontDeskPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  role: () => Promise<AsyncIterator<Role>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InstructorSubscriptionPayload {
  mutation: MutationType;
  node: Instructor;
  updatedFields: String[];
  previousValues: InstructorPreviousValues;
}

export interface InstructorSubscriptionPayloadPromise
  extends Promise<InstructorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InstructorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InstructorPreviousValuesPromise>() => T;
}

export interface InstructorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InstructorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InstructorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InstructorPreviousValuesSubscription>() => T;
}

export interface InstructorPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role;
  imageURL: String;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InstructorPreviousValuesPromise
  extends Promise<InstructorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InstructorPreviousValuesSubscription
  extends Promise<AsyncIterator<InstructorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  bio: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LessonSubscriptionPayload {
  mutation: MutationType;
  node: Lesson;
  updatedFields: String[];
  previousValues: LessonPreviousValues;
}

export interface LessonSubscriptionPayloadPromise
  extends Promise<LessonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LessonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LessonPreviousValuesPromise>() => T;
}

export interface LessonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LessonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LessonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LessonPreviousValuesSubscription>() => T;
}

export interface LessonPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  duration: Int;
  calendarColor: Color;
  price: Int;
  day: Day;
  time: DateTimeOutput;
  open: Boolean;
}

export interface LessonPreviousValuesPromise
  extends Promise<LessonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  calendarColor: () => Promise<Color>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  time: () => Promise<DateTimeOutput>;
  open: () => Promise<Boolean>;
}

export interface LessonPreviousValuesSubscription
  extends Promise<AsyncIterator<LessonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  calendarColor: () => Promise<AsyncIterator<Color>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface MedicalConditionSubscriptionPayload {
  mutation: MutationType;
  node: MedicalCondition;
  updatedFields: String[];
  previousValues: MedicalConditionPreviousValues;
}

export interface MedicalConditionSubscriptionPayloadPromise
  extends Promise<MedicalConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MedicalConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MedicalConditionPreviousValuesPromise>() => T;
}

export interface MedicalConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MedicalConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MedicalConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MedicalConditionPreviousValuesSubscription>() => T;
}

export interface MedicalConditionPreviousValues {
  id: ID_Output;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicalConditionPreviousValuesPromise
  extends Promise<MedicalConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicalConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<MedicalConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  gender: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  skill: () => Promise<SkillLevel>;
  gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  skill: () => Promise<AsyncIterator<SkillLevel>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "SkillLevel",
    embedded: false
  },
  {
    name: "LessonType",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "Color",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "AccountAdmin",
    embedded: false
  },
  {
    name: "FrontDesk",
    embedded: false
  },
  {
    name: "Instructor",
    embedded: false
  },
  {
    name: "MedicalCondition",
    embedded: false
  },
  {
    name: "Class",
    embedded: false
  },
  {
    name: "Lesson",
    embedded: false
  },
  {
    name: "AgeGroup",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
