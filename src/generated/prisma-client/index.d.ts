// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  ageGroup: (where?: AgeGroupWhereInput) => Promise<boolean>;
  class: (where?: ClassWhereInput) => Promise<boolean>;
  client: (where?: ClientWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  lesson: (where?: LessonWhereInput) => Promise<boolean>;
  medicalCondition: (where?: MedicalConditionWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  messageTag: (where?: MessageTagWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  ageGroup: (where: AgeGroupWhereUniqueInput) => AgeGroupNullablePromise;
  ageGroups: (args?: {
    where?: AgeGroupWhereInput;
    orderBy?: AgeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AgeGroup>;
  ageGroupsConnection: (args?: {
    where?: AgeGroupWhereInput;
    orderBy?: AgeGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AgeGroupConnectionPromise;
  class: (where: ClassWhereUniqueInput) => ClassNullablePromise;
  classes: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Class>;
  classesConnection: (args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClassConnectionPromise;
  client: (where: ClientWhereUniqueInput) => ClientNullablePromise;
  clients: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Client>;
  clientsConnection: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClientConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeeNullablePromise;
  employees: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Employee>;
  employeesConnection: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeeConnectionPromise;
  lesson: (where: LessonWhereUniqueInput) => LessonNullablePromise;
  lessons: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lesson>;
  lessonsConnection: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LessonConnectionPromise;
  medicalCondition: (
    where: MedicalConditionWhereUniqueInput
  ) => MedicalConditionNullablePromise;
  medicalConditions: (args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MedicalCondition>;
  medicalConditionsConnection: (args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MedicalConditionConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  messageTag: (where: MessageTagWhereUniqueInput) => MessageTagNullablePromise;
  messageTags: (args?: {
    where?: MessageTagWhereInput;
    orderBy?: MessageTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MessageTag>;
  messageTagsConnection: (args?: {
    where?: MessageTagWhereInput;
    orderBy?: MessageTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageTagConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentNullablePromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAgeGroup: (data: AgeGroupCreateInput) => AgeGroupPromise;
  updateAgeGroup: (args: {
    data: AgeGroupUpdateInput;
    where: AgeGroupWhereUniqueInput;
  }) => AgeGroupPromise;
  updateManyAgeGroups: (args: {
    data: AgeGroupUpdateManyMutationInput;
    where?: AgeGroupWhereInput;
  }) => BatchPayloadPromise;
  upsertAgeGroup: (args: {
    where: AgeGroupWhereUniqueInput;
    create: AgeGroupCreateInput;
    update: AgeGroupUpdateInput;
  }) => AgeGroupPromise;
  deleteAgeGroup: (where: AgeGroupWhereUniqueInput) => AgeGroupPromise;
  deleteManyAgeGroups: (where?: AgeGroupWhereInput) => BatchPayloadPromise;
  createClass: (data: ClassCreateInput) => ClassPromise;
  updateClass: (args: {
    data: ClassUpdateInput;
    where: ClassWhereUniqueInput;
  }) => ClassPromise;
  updateManyClasses: (args: {
    data: ClassUpdateManyMutationInput;
    where?: ClassWhereInput;
  }) => BatchPayloadPromise;
  upsertClass: (args: {
    where: ClassWhereUniqueInput;
    create: ClassCreateInput;
    update: ClassUpdateInput;
  }) => ClassPromise;
  deleteClass: (where: ClassWhereUniqueInput) => ClassPromise;
  deleteManyClasses: (where?: ClassWhereInput) => BatchPayloadPromise;
  createClient: (data: ClientCreateInput) => ClientPromise;
  updateClient: (args: {
    data: ClientUpdateInput;
    where: ClientWhereUniqueInput;
  }) => ClientPromise;
  updateManyClients: (args: {
    data: ClientUpdateManyMutationInput;
    where?: ClientWhereInput;
  }) => BatchPayloadPromise;
  upsertClient: (args: {
    where: ClientWhereUniqueInput;
    create: ClientCreateInput;
    update: ClientUpdateInput;
  }) => ClientPromise;
  deleteClient: (where: ClientWhereUniqueInput) => ClientPromise;
  deleteManyClients: (where?: ClientWhereInput) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (args: {
    data: EmployeeUpdateInput;
    where: EmployeeWhereUniqueInput;
  }) => EmployeePromise;
  updateManyEmployees: (args: {
    data: EmployeeUpdateManyMutationInput;
    where?: EmployeeWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployee: (args: {
    where: EmployeeWhereUniqueInput;
    create: EmployeeCreateInput;
    update: EmployeeUpdateInput;
  }) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createLesson: (data: LessonCreateInput) => LessonPromise;
  updateLesson: (args: {
    data: LessonUpdateInput;
    where: LessonWhereUniqueInput;
  }) => LessonPromise;
  updateManyLessons: (args: {
    data: LessonUpdateManyMutationInput;
    where?: LessonWhereInput;
  }) => BatchPayloadPromise;
  upsertLesson: (args: {
    where: LessonWhereUniqueInput;
    create: LessonCreateInput;
    update: LessonUpdateInput;
  }) => LessonPromise;
  deleteLesson: (where: LessonWhereUniqueInput) => LessonPromise;
  deleteManyLessons: (where?: LessonWhereInput) => BatchPayloadPromise;
  createMedicalCondition: (
    data: MedicalConditionCreateInput
  ) => MedicalConditionPromise;
  updateMedicalCondition: (args: {
    data: MedicalConditionUpdateInput;
    where: MedicalConditionWhereUniqueInput;
  }) => MedicalConditionPromise;
  updateManyMedicalConditions: (args: {
    data: MedicalConditionUpdateManyMutationInput;
    where?: MedicalConditionWhereInput;
  }) => BatchPayloadPromise;
  upsertMedicalCondition: (args: {
    where: MedicalConditionWhereUniqueInput;
    create: MedicalConditionCreateInput;
    update: MedicalConditionUpdateInput;
  }) => MedicalConditionPromise;
  deleteMedicalCondition: (
    where: MedicalConditionWhereUniqueInput
  ) => MedicalConditionPromise;
  deleteManyMedicalConditions: (
    where?: MedicalConditionWhereInput
  ) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createMessageTag: (data: MessageTagCreateInput) => MessageTagPromise;
  updateMessageTag: (args: {
    data: MessageTagUpdateInput;
    where: MessageTagWhereUniqueInput;
  }) => MessageTagPromise;
  updateManyMessageTags: (args: {
    data: MessageTagUpdateManyMutationInput;
    where?: MessageTagWhereInput;
  }) => BatchPayloadPromise;
  upsertMessageTag: (args: {
    where: MessageTagWhereUniqueInput;
    create: MessageTagCreateInput;
    update: MessageTagUpdateInput;
  }) => MessageTagPromise;
  deleteMessageTag: (where: MessageTagWhereUniqueInput) => MessageTagPromise;
  deleteManyMessageTags: (where?: MessageTagWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  ageGroup: (
    where?: AgeGroupSubscriptionWhereInput
  ) => AgeGroupSubscriptionPayloadSubscription;
  class: (
    where?: ClassSubscriptionWhereInput
  ) => ClassSubscriptionPayloadSubscription;
  client: (
    where?: ClientSubscriptionWhereInput
  ) => ClientSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  lesson: (
    where?: LessonSubscriptionWhereInput
  ) => LessonSubscriptionPayloadSubscription;
  medicalCondition: (
    where?: MedicalConditionSubscriptionWhereInput
  ) => MedicalConditionSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  messageTag: (
    where?: MessageTagSubscriptionWhereInput
  ) => MessageTagSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AgeGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "minAge_ASC"
  | "minAge_DESC"
  | "maxAge_ASC"
  | "maxAge_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SkillLevel = "BEGINNER" | "INTERMEDIATE" | "ADVANCED";

export type Day =
  | "SUNDAY"
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY";

export type Gender = "MALE" | "FEMALE" | "OTHER";

export type Role = "ADMIN" | "INSTRUCTOR" | "FRONT_DESK";

export type LessonType = "SINGLE" | "PAIR";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "skill_ASC"
  | "skill_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClassOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "level_ASC"
  | "level_DESC"
  | "capacity_ASC"
  | "capacity_DESC"
  | "price_ASC"
  | "price_DESC"
  | "day_ASC"
  | "day_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "time_ASC"
  | "time_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LessonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "type_ASC"
  | "type_DESC"
  | "day_ASC"
  | "day_DESC"
  | "time_ASC"
  | "time_DESC"
  | "open_ASC"
  | "open_DESC";

export type MedicalConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmployeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "imageURL_ASC"
  | "imageURL_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "currentEmployee_ASC"
  | "currentEmployee_DESC"
  | "lessonSinglePrice_ASC"
  | "lessonSinglePrice_DESC"
  | "lessonDoublePrice_ASC"
  | "lessonDoublePrice_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MessageTagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "tag_ASC"
  | "tag_DESC";

export type ClientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "address_ASC"
  | "address_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "stripeId_ASC"
  | "stripeId_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AgeGroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AgeGroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  minAge?: Maybe<Int>;
  minAge_not?: Maybe<Int>;
  minAge_in?: Maybe<Int[] | Int>;
  minAge_not_in?: Maybe<Int[] | Int>;
  minAge_lt?: Maybe<Int>;
  minAge_lte?: Maybe<Int>;
  minAge_gt?: Maybe<Int>;
  minAge_gte?: Maybe<Int>;
  maxAge?: Maybe<Int>;
  maxAge_not?: Maybe<Int>;
  maxAge_in?: Maybe<Int[] | Int>;
  maxAge_not_in?: Maybe<Int[] | Int>;
  maxAge_lt?: Maybe<Int>;
  maxAge_lte?: Maybe<Int>;
  maxAge_gt?: Maybe<Int>;
  maxAge_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AgeGroupWhereInput[] | AgeGroupWhereInput>;
  OR?: Maybe<AgeGroupWhereInput[] | AgeGroupWhereInput>;
  NOT?: Maybe<AgeGroupWhereInput[] | AgeGroupWhereInput>;
}

export type ClassWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StudentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  birthday?: Maybe<String>;
  birthday_not?: Maybe<String>;
  birthday_in?: Maybe<String[] | String>;
  birthday_not_in?: Maybe<String[] | String>;
  birthday_lt?: Maybe<String>;
  birthday_lte?: Maybe<String>;
  birthday_gt?: Maybe<String>;
  birthday_gte?: Maybe<String>;
  birthday_contains?: Maybe<String>;
  birthday_not_contains?: Maybe<String>;
  birthday_starts_with?: Maybe<String>;
  birthday_not_starts_with?: Maybe<String>;
  birthday_ends_with?: Maybe<String>;
  birthday_not_ends_with?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  skill_not?: Maybe<SkillLevel>;
  skill_in?: Maybe<SkillLevel[] | SkillLevel>;
  skill_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  ageGroup?: Maybe<AgeGroupWhereInput>;
  classes_every?: Maybe<ClassWhereInput>;
  classes_some?: Maybe<ClassWhereInput>;
  classes_none?: Maybe<ClassWhereInput>;
  lessons_every?: Maybe<LessonWhereInput>;
  lessons_some?: Maybe<LessonWhereInput>;
  lessons_none?: Maybe<LessonWhereInput>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  medical_every?: Maybe<MedicalConditionWhereInput>;
  medical_some?: Maybe<MedicalConditionWhereInput>;
  medical_none?: Maybe<MedicalConditionWhereInput>;
  admin?: Maybe<ClientWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StudentWhereInput[] | StudentWhereInput>;
  OR?: Maybe<StudentWhereInput[] | StudentWhereInput>;
  NOT?: Maybe<StudentWhereInput[] | StudentWhereInput>;
}

export interface ClassWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  ageGroup?: Maybe<AgeGroupWhereInput>;
  level?: Maybe<SkillLevel>;
  level_not?: Maybe<SkillLevel>;
  level_in?: Maybe<SkillLevel[] | SkillLevel>;
  level_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  capacity?: Maybe<Int>;
  capacity_not?: Maybe<Int>;
  capacity_in?: Maybe<Int[] | Int>;
  capacity_not_in?: Maybe<Int[] | Int>;
  capacity_lt?: Maybe<Int>;
  capacity_lte?: Maybe<Int>;
  capacity_gt?: Maybe<Int>;
  capacity_gte?: Maybe<Int>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  instructor?: Maybe<EmployeeWhereInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  students_every?: Maybe<StudentWhereInput>;
  students_some?: Maybe<StudentWhereInput>;
  students_none?: Maybe<StudentWhereInput>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClassWhereInput[] | ClassWhereInput>;
  OR?: Maybe<ClassWhereInput[] | ClassWhereInput>;
  NOT?: Maybe<ClassWhereInput[] | ClassWhereInput>;
}

export interface EmployeeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  imageURL?: Maybe<String>;
  imageURL_not?: Maybe<String>;
  imageURL_in?: Maybe<String[] | String>;
  imageURL_not_in?: Maybe<String[] | String>;
  imageURL_lt?: Maybe<String>;
  imageURL_lte?: Maybe<String>;
  imageURL_gt?: Maybe<String>;
  imageURL_gte?: Maybe<String>;
  imageURL_contains?: Maybe<String>;
  imageURL_not_contains?: Maybe<String>;
  imageURL_starts_with?: Maybe<String>;
  imageURL_not_starts_with?: Maybe<String>;
  imageURL_ends_with?: Maybe<String>;
  imageURL_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  currentEmployee_not?: Maybe<Boolean>;
  clients_every?: Maybe<StudentWhereInput>;
  clients_some?: Maybe<StudentWhereInput>;
  clients_none?: Maybe<StudentWhereInput>;
  classes_every?: Maybe<ClassWhereInput>;
  classes_some?: Maybe<ClassWhereInput>;
  classes_none?: Maybe<ClassWhereInput>;
  lessons_every?: Maybe<LessonWhereInput>;
  lessons_some?: Maybe<LessonWhereInput>;
  lessons_none?: Maybe<LessonWhereInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonSinglePrice_not?: Maybe<Int>;
  lessonSinglePrice_in?: Maybe<Int[] | Int>;
  lessonSinglePrice_not_in?: Maybe<Int[] | Int>;
  lessonSinglePrice_lt?: Maybe<Int>;
  lessonSinglePrice_lte?: Maybe<Int>;
  lessonSinglePrice_gt?: Maybe<Int>;
  lessonSinglePrice_gte?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  lessonDoublePrice_not?: Maybe<Int>;
  lessonDoublePrice_in?: Maybe<Int[] | Int>;
  lessonDoublePrice_not_in?: Maybe<Int[] | Int>;
  lessonDoublePrice_lt?: Maybe<Int>;
  lessonDoublePrice_lte?: Maybe<Int>;
  lessonDoublePrice_gt?: Maybe<Int>;
  lessonDoublePrice_gte?: Maybe<Int>;
  createdMessages_every?: Maybe<MessageWhereInput>;
  createdMessages_some?: Maybe<MessageWhereInput>;
  createdMessages_none?: Maybe<MessageWhereInput>;
  taggedMessages_every?: Maybe<MessageWhereInput>;
  taggedMessages_some?: Maybe<MessageWhereInput>;
  taggedMessages_none?: Maybe<MessageWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  OR?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  NOT?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
}

export interface LessonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  instructor?: Maybe<EmployeeWhereInput>;
  client_every?: Maybe<StudentWhereInput>;
  client_some?: Maybe<StudentWhereInput>;
  client_none?: Maybe<StudentWhereInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  type?: Maybe<LessonType>;
  type_not?: Maybe<LessonType>;
  type_in?: Maybe<LessonType[] | LessonType>;
  type_not_in?: Maybe<LessonType[] | LessonType>;
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  open?: Maybe<Boolean>;
  open_not?: Maybe<Boolean>;
  AND?: Maybe<LessonWhereInput[] | LessonWhereInput>;
  OR?: Maybe<LessonWhereInput[] | LessonWhereInput>;
  NOT?: Maybe<LessonWhereInput[] | LessonWhereInput>;
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  author?: Maybe<EmployeeWhereInput>;
  parent?: Maybe<MessageWhereInput>;
  taggedEmployees_every?: Maybe<EmployeeWhereInput>;
  taggedEmployees_some?: Maybe<EmployeeWhereInput>;
  taggedEmployees_none?: Maybe<EmployeeWhereInput>;
  tags_every?: Maybe<MessageTagWhereInput>;
  tags_some?: Maybe<MessageTagWhereInput>;
  tags_none?: Maybe<MessageTagWhereInput>;
  comments_every?: Maybe<MessageWhereInput>;
  comments_some?: Maybe<MessageWhereInput>;
  comments_none?: Maybe<MessageWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  OR?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export interface MessageTagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  tag?: Maybe<String>;
  tag_not?: Maybe<String>;
  tag_in?: Maybe<String[] | String>;
  tag_not_in?: Maybe<String[] | String>;
  tag_lt?: Maybe<String>;
  tag_lte?: Maybe<String>;
  tag_gt?: Maybe<String>;
  tag_gte?: Maybe<String>;
  tag_contains?: Maybe<String>;
  tag_not_contains?: Maybe<String>;
  tag_starts_with?: Maybe<String>;
  tag_not_starts_with?: Maybe<String>;
  tag_ends_with?: Maybe<String>;
  tag_not_ends_with?: Maybe<String>;
  messages_every?: Maybe<MessageWhereInput>;
  messages_some?: Maybe<MessageWhereInput>;
  messages_none?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageTagWhereInput[] | MessageTagWhereInput>;
  OR?: Maybe<MessageTagWhereInput[] | MessageTagWhereInput>;
  NOT?: Maybe<MessageTagWhereInput[] | MessageTagWhereInput>;
}

export interface MedicalConditionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  student?: Maybe<StudentWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MedicalConditionWhereInput[] | MedicalConditionWhereInput>;
  OR?: Maybe<MedicalConditionWhereInput[] | MedicalConditionWhereInput>;
  NOT?: Maybe<MedicalConditionWhereInput[] | MedicalConditionWhereInput>;
}

export interface ClientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  students_every?: Maybe<StudentWhereInput>;
  students_some?: Maybe<StudentWhereInput>;
  students_none?: Maybe<StudentWhereInput>;
  stripeId?: Maybe<String>;
  stripeId_not?: Maybe<String>;
  stripeId_in?: Maybe<String[] | String>;
  stripeId_not_in?: Maybe<String[] | String>;
  stripeId_lt?: Maybe<String>;
  stripeId_lte?: Maybe<String>;
  stripeId_gt?: Maybe<String>;
  stripeId_gte?: Maybe<String>;
  stripeId_contains?: Maybe<String>;
  stripeId_not_contains?: Maybe<String>;
  stripeId_starts_with?: Maybe<String>;
  stripeId_not_starts_with?: Maybe<String>;
  stripeId_ends_with?: Maybe<String>;
  stripeId_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
  resetTokenExpiry_not?: Maybe<String>;
  resetTokenExpiry_in?: Maybe<String[] | String>;
  resetTokenExpiry_not_in?: Maybe<String[] | String>;
  resetTokenExpiry_lt?: Maybe<String>;
  resetTokenExpiry_lte?: Maybe<String>;
  resetTokenExpiry_gt?: Maybe<String>;
  resetTokenExpiry_gte?: Maybe<String>;
  resetTokenExpiry_contains?: Maybe<String>;
  resetTokenExpiry_not_contains?: Maybe<String>;
  resetTokenExpiry_starts_with?: Maybe<String>;
  resetTokenExpiry_not_starts_with?: Maybe<String>;
  resetTokenExpiry_ends_with?: Maybe<String>;
  resetTokenExpiry_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  OR?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  NOT?: Maybe<ClientWhereInput[] | ClientWhereInput>;
}

export type ClientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
}>;

export type LessonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MedicalConditionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MessageTagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type StudentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AgeGroupCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  minAge: Int;
  maxAge?: Maybe<Int>;
}

export interface AgeGroupUpdateInput {
  name?: Maybe<String>;
  minAge?: Maybe<Int>;
  maxAge?: Maybe<Int>;
}

export interface AgeGroupUpdateManyMutationInput {
  name?: Maybe<String>;
  minAge?: Maybe<Int>;
  maxAge?: Maybe<Int>;
}

export interface ClassCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  instructor: EmployeeCreateOneWithoutClassesInput;
  duration: Int;
  students?: Maybe<StudentCreateManyWithoutClassesInput>;
  time: String;
}

export interface AgeGroupCreateOneInput {
  create?: Maybe<AgeGroupCreateInput>;
  connect?: Maybe<AgeGroupWhereUniqueInput>;
}

export interface EmployeeCreateOneWithoutClassesInput {
  create?: Maybe<EmployeeCreateWithoutClassesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutClassesInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role?: Maybe<EmployeeCreateroleInput>;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentCreateManyInput>;
  lessons?: Maybe<LessonCreateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  createdMessages?: Maybe<MessageCreateManyWithoutAuthorInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedEmployeesInput>;
}

export interface EmployeeCreateroleInput {
  set?: Maybe<Role[] | Role>;
}

export interface StudentCreateManyInput {
  create?: Maybe<StudentCreateInput[] | StudentCreateInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: Maybe<ClassCreateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonCreateManyWithoutClientInput>;
  gender: Gender;
  medical?: Maybe<MedicalConditionCreateManyWithoutStudentInput>;
  admin?: Maybe<ClientCreateOneWithoutStudentsInput>;
}

export interface ClassCreateManyWithoutStudentsInput {
  create?: Maybe<
    ClassCreateWithoutStudentsInput[] | ClassCreateWithoutStudentsInput
  >;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
}

export interface ClassCreateWithoutStudentsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  instructor: EmployeeCreateOneWithoutClassesInput;
  duration: Int;
  time: String;
}

export interface LessonCreateManyWithoutClientInput {
  create?: Maybe<
    LessonCreateWithoutClientInput[] | LessonCreateWithoutClientInput
  >;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
}

export interface LessonCreateWithoutClientInput {
  id?: Maybe<ID_Input>;
  instructor: EmployeeCreateOneWithoutLessonsInput;
  duration: Int;
  type?: Maybe<LessonType>;
  day: Day;
  time: String;
  open: Boolean;
}

export interface EmployeeCreateOneWithoutLessonsInput {
  create?: Maybe<EmployeeCreateWithoutLessonsInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutLessonsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role?: Maybe<EmployeeCreateroleInput>;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentCreateManyInput>;
  classes?: Maybe<ClassCreateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  createdMessages?: Maybe<MessageCreateManyWithoutAuthorInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedEmployeesInput>;
}

export interface ClassCreateManyWithoutInstructorInput {
  create?: Maybe<
    ClassCreateWithoutInstructorInput[] | ClassCreateWithoutInstructorInput
  >;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
}

export interface ClassCreateWithoutInstructorInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  description: String;
  ageGroup: AgeGroupCreateOneInput;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  students?: Maybe<StudentCreateManyWithoutClassesInput>;
  time: String;
}

export interface StudentCreateManyWithoutClassesInput {
  create?: Maybe<
    StudentCreateWithoutClassesInput[] | StudentCreateWithoutClassesInput
  >;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateWithoutClassesInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  lessons?: Maybe<LessonCreateManyWithoutClientInput>;
  gender: Gender;
  medical?: Maybe<MedicalConditionCreateManyWithoutStudentInput>;
  admin?: Maybe<ClientCreateOneWithoutStudentsInput>;
}

export interface MedicalConditionCreateManyWithoutStudentInput {
  create?: Maybe<
    | MedicalConditionCreateWithoutStudentInput[]
    | MedicalConditionCreateWithoutStudentInput
  >;
  connect?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
}

export interface MedicalConditionCreateWithoutStudentInput {
  id?: Maybe<ID_Input>;
  description: String;
}

export interface ClientCreateOneWithoutStudentsInput {
  create?: Maybe<ClientCreateWithoutStudentsInput>;
  connect?: Maybe<ClientWhereUniqueInput>;
}

export interface ClientCreateWithoutStudentsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface MessageCreateManyWithoutAuthorInput {
  create?: Maybe<
    MessageCreateWithoutAuthorInput[] | MessageCreateWithoutAuthorInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title: String;
  text: String;
  parent?: Maybe<MessageCreateOneWithoutParentInput>;
  taggedEmployees?: Maybe<EmployeeCreateManyWithoutTaggedMessagesInput>;
  tags?: Maybe<MessageTagCreateManyWithoutMessagesInput>;
  comments?: Maybe<MessageCreateManyWithoutCommentsInput>;
}

export interface MessageCreateOneWithoutParentInput {
  create?: Maybe<MessageCreateWithoutParentInput>;
  connect?: Maybe<MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  title: String;
  text: String;
  author: EmployeeCreateOneWithoutCreatedMessagesInput;
  taggedEmployees?: Maybe<EmployeeCreateManyWithoutTaggedMessagesInput>;
  tags?: Maybe<MessageTagCreateManyWithoutMessagesInput>;
  comments?: Maybe<MessageCreateManyWithoutCommentsInput>;
}

export interface EmployeeCreateOneWithoutCreatedMessagesInput {
  create?: Maybe<EmployeeCreateWithoutCreatedMessagesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutCreatedMessagesInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role?: Maybe<EmployeeCreateroleInput>;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentCreateManyInput>;
  classes?: Maybe<ClassCreateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonCreateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedEmployeesInput>;
}

export interface LessonCreateManyWithoutInstructorInput {
  create?: Maybe<
    LessonCreateWithoutInstructorInput[] | LessonCreateWithoutInstructorInput
  >;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
}

export interface LessonCreateWithoutInstructorInput {
  id?: Maybe<ID_Input>;
  client?: Maybe<StudentCreateManyWithoutLessonsInput>;
  duration: Int;
  type?: Maybe<LessonType>;
  day: Day;
  time: String;
  open: Boolean;
}

export interface StudentCreateManyWithoutLessonsInput {
  create?: Maybe<
    StudentCreateWithoutLessonsInput[] | StudentCreateWithoutLessonsInput
  >;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateWithoutLessonsInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: Maybe<ClassCreateManyWithoutStudentsInput>;
  gender: Gender;
  medical?: Maybe<MedicalConditionCreateManyWithoutStudentInput>;
  admin?: Maybe<ClientCreateOneWithoutStudentsInput>;
}

export interface MessageCreateManyWithoutTaggedEmployeesInput {
  create?: Maybe<
    | MessageCreateWithoutTaggedEmployeesInput[]
    | MessageCreateWithoutTaggedEmployeesInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutTaggedEmployeesInput {
  id?: Maybe<ID_Input>;
  title: String;
  text: String;
  author: EmployeeCreateOneWithoutCreatedMessagesInput;
  parent?: Maybe<MessageCreateOneWithoutParentInput>;
  tags?: Maybe<MessageTagCreateManyWithoutMessagesInput>;
  comments?: Maybe<MessageCreateManyWithoutCommentsInput>;
}

export interface MessageTagCreateManyWithoutMessagesInput {
  create?: Maybe<
    | MessageTagCreateWithoutMessagesInput[]
    | MessageTagCreateWithoutMessagesInput
  >;
  connect?: Maybe<MessageTagWhereUniqueInput[] | MessageTagWhereUniqueInput>;
}

export interface MessageTagCreateWithoutMessagesInput {
  id?: Maybe<ID_Input>;
  tag: String;
}

export interface MessageCreateManyWithoutCommentsInput {
  create?: Maybe<
    MessageCreateWithoutCommentsInput[] | MessageCreateWithoutCommentsInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  title: String;
  text: String;
  author: EmployeeCreateOneWithoutCreatedMessagesInput;
  parent?: Maybe<MessageCreateOneWithoutParentInput>;
  taggedEmployees?: Maybe<EmployeeCreateManyWithoutTaggedMessagesInput>;
  tags?: Maybe<MessageTagCreateManyWithoutMessagesInput>;
}

export interface EmployeeCreateManyWithoutTaggedMessagesInput {
  create?: Maybe<
    | EmployeeCreateWithoutTaggedMessagesInput[]
    | EmployeeCreateWithoutTaggedMessagesInput
  >;
  connect?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutTaggedMessagesInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role?: Maybe<EmployeeCreateroleInput>;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentCreateManyInput>;
  classes?: Maybe<ClassCreateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonCreateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  createdMessages?: Maybe<MessageCreateManyWithoutAuthorInput>;
}

export interface ClassUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  instructor?: Maybe<EmployeeUpdateOneRequiredWithoutClassesInput>;
  duration?: Maybe<Int>;
  students?: Maybe<StudentUpdateManyWithoutClassesInput>;
  time?: Maybe<String>;
}

export interface AgeGroupUpdateOneRequiredInput {
  create?: Maybe<AgeGroupCreateInput>;
  update?: Maybe<AgeGroupUpdateDataInput>;
  upsert?: Maybe<AgeGroupUpsertNestedInput>;
  connect?: Maybe<AgeGroupWhereUniqueInput>;
}

export interface AgeGroupUpdateDataInput {
  name?: Maybe<String>;
  minAge?: Maybe<Int>;
  maxAge?: Maybe<Int>;
}

export interface AgeGroupUpsertNestedInput {
  update: AgeGroupUpdateDataInput;
  create: AgeGroupCreateInput;
}

export interface EmployeeUpdateOneRequiredWithoutClassesInput {
  create?: Maybe<EmployeeCreateWithoutClassesInput>;
  update?: Maybe<EmployeeUpdateWithoutClassesDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutClassesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutClassesDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<EmployeeUpdateroleInput>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  lessons?: Maybe<LessonUpdateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  createdMessages?: Maybe<MessageUpdateManyWithoutAuthorInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedEmployeesInput>;
}

export interface EmployeeUpdateroleInput {
  set?: Maybe<Role[] | Role>;
}

export interface StudentUpdateManyInput {
  create?: Maybe<StudentCreateInput[] | StudentCreateInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueNestedInput[]
    | StudentUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueNestedInput[]
    | StudentUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateDataInput;
}

export interface StudentUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
  admin?: Maybe<ClientUpdateOneWithoutStudentsInput>;
}

export interface ClassUpdateManyWithoutStudentsInput {
  create?: Maybe<
    ClassCreateWithoutStudentsInput[] | ClassCreateWithoutStudentsInput
  >;
  delete?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  set?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  disconnect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  update?: Maybe<
    | ClassUpdateWithWhereUniqueWithoutStudentsInput[]
    | ClassUpdateWithWhereUniqueWithoutStudentsInput
  >;
  upsert?: Maybe<
    | ClassUpsertWithWhereUniqueWithoutStudentsInput[]
    | ClassUpsertWithWhereUniqueWithoutStudentsInput
  >;
  deleteMany?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  updateMany?: Maybe<
    ClassUpdateManyWithWhereNestedInput[] | ClassUpdateManyWithWhereNestedInput
  >;
}

export interface ClassUpdateWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutStudentsDataInput;
}

export interface ClassUpdateWithoutStudentsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  instructor?: Maybe<EmployeeUpdateOneRequiredWithoutClassesInput>;
  duration?: Maybe<Int>;
  time?: Maybe<String>;
}

export interface ClassUpsertWithWhereUniqueWithoutStudentsInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutStudentsDataInput;
  create: ClassCreateWithoutStudentsInput;
}

export interface ClassScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  level?: Maybe<SkillLevel>;
  level_not?: Maybe<SkillLevel>;
  level_in?: Maybe<SkillLevel[] | SkillLevel>;
  level_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  capacity?: Maybe<Int>;
  capacity_not?: Maybe<Int>;
  capacity_in?: Maybe<Int[] | Int>;
  capacity_not_in?: Maybe<Int[] | Int>;
  capacity_lt?: Maybe<Int>;
  capacity_lte?: Maybe<Int>;
  capacity_gt?: Maybe<Int>;
  capacity_gte?: Maybe<Int>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  OR?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  NOT?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
}

export interface ClassUpdateManyWithWhereNestedInput {
  where: ClassScalarWhereInput;
  data: ClassUpdateManyDataInput;
}

export interface ClassUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  duration?: Maybe<Int>;
  time?: Maybe<String>;
}

export interface LessonUpdateManyWithoutClientInput {
  create?: Maybe<
    LessonCreateWithoutClientInput[] | LessonCreateWithoutClientInput
  >;
  delete?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  set?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  disconnect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  update?: Maybe<
    | LessonUpdateWithWhereUniqueWithoutClientInput[]
    | LessonUpdateWithWhereUniqueWithoutClientInput
  >;
  upsert?: Maybe<
    | LessonUpsertWithWhereUniqueWithoutClientInput[]
    | LessonUpsertWithWhereUniqueWithoutClientInput
  >;
  deleteMany?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  updateMany?: Maybe<
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput
  >;
}

export interface LessonUpdateWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutClientDataInput;
}

export interface LessonUpdateWithoutClientDataInput {
  instructor?: Maybe<EmployeeUpdateOneRequiredWithoutLessonsInput>;
  duration?: Maybe<Int>;
  type?: Maybe<LessonType>;
  day?: Maybe<Day>;
  time?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface EmployeeUpdateOneRequiredWithoutLessonsInput {
  create?: Maybe<EmployeeCreateWithoutLessonsInput>;
  update?: Maybe<EmployeeUpdateWithoutLessonsDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutLessonsInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutLessonsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<EmployeeUpdateroleInput>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  classes?: Maybe<ClassUpdateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  createdMessages?: Maybe<MessageUpdateManyWithoutAuthorInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedEmployeesInput>;
}

export interface ClassUpdateManyWithoutInstructorInput {
  create?: Maybe<
    ClassCreateWithoutInstructorInput[] | ClassCreateWithoutInstructorInput
  >;
  delete?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  connect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  set?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  disconnect?: Maybe<ClassWhereUniqueInput[] | ClassWhereUniqueInput>;
  update?: Maybe<
    | ClassUpdateWithWhereUniqueWithoutInstructorInput[]
    | ClassUpdateWithWhereUniqueWithoutInstructorInput
  >;
  upsert?: Maybe<
    | ClassUpsertWithWhereUniqueWithoutInstructorInput[]
    | ClassUpsertWithWhereUniqueWithoutInstructorInput
  >;
  deleteMany?: Maybe<ClassScalarWhereInput[] | ClassScalarWhereInput>;
  updateMany?: Maybe<
    ClassUpdateManyWithWhereNestedInput[] | ClassUpdateManyWithWhereNestedInput
  >;
}

export interface ClassUpdateWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput;
  data: ClassUpdateWithoutInstructorDataInput;
}

export interface ClassUpdateWithoutInstructorDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  duration?: Maybe<Int>;
  students?: Maybe<StudentUpdateManyWithoutClassesInput>;
  time?: Maybe<String>;
}

export interface StudentUpdateManyWithoutClassesInput {
  create?: Maybe<
    StudentCreateWithoutClassesInput[] | StudentCreateWithoutClassesInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueWithoutClassesInput[]
    | StudentUpdateWithWhereUniqueWithoutClassesInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueWithoutClassesInput[]
    | StudentUpsertWithWhereUniqueWithoutClassesInput
  >;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutClassesDataInput;
}

export interface StudentUpdateWithoutClassesDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
  admin?: Maybe<ClientUpdateOneWithoutStudentsInput>;
}

export interface MedicalConditionUpdateManyWithoutStudentInput {
  create?: Maybe<
    | MedicalConditionCreateWithoutStudentInput[]
    | MedicalConditionCreateWithoutStudentInput
  >;
  delete?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
  connect?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
  set?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
  disconnect?: Maybe<
    MedicalConditionWhereUniqueInput[] | MedicalConditionWhereUniqueInput
  >;
  update?: Maybe<
    | MedicalConditionUpdateWithWhereUniqueWithoutStudentInput[]
    | MedicalConditionUpdateWithWhereUniqueWithoutStudentInput
  >;
  upsert?: Maybe<
    | MedicalConditionUpsertWithWhereUniqueWithoutStudentInput[]
    | MedicalConditionUpsertWithWhereUniqueWithoutStudentInput
  >;
  deleteMany?: Maybe<
    MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput
  >;
  updateMany?: Maybe<
    | MedicalConditionUpdateManyWithWhereNestedInput[]
    | MedicalConditionUpdateManyWithWhereNestedInput
  >;
}

export interface MedicalConditionUpdateWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput;
  data: MedicalConditionUpdateWithoutStudentDataInput;
}

export interface MedicalConditionUpdateWithoutStudentDataInput {
  description?: Maybe<String>;
}

export interface MedicalConditionUpsertWithWhereUniqueWithoutStudentInput {
  where: MedicalConditionWhereUniqueInput;
  update: MedicalConditionUpdateWithoutStudentDataInput;
  create: MedicalConditionCreateWithoutStudentInput;
}

export interface MedicalConditionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput
  >;
  OR?: Maybe<
    MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput
  >;
  NOT?: Maybe<
    MedicalConditionScalarWhereInput[] | MedicalConditionScalarWhereInput
  >;
}

export interface MedicalConditionUpdateManyWithWhereNestedInput {
  where: MedicalConditionScalarWhereInput;
  data: MedicalConditionUpdateManyDataInput;
}

export interface MedicalConditionUpdateManyDataInput {
  description?: Maybe<String>;
}

export interface ClientUpdateOneWithoutStudentsInput {
  create?: Maybe<ClientCreateWithoutStudentsInput>;
  update?: Maybe<ClientUpdateWithoutStudentsDataInput>;
  upsert?: Maybe<ClientUpsertWithoutStudentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ClientWhereUniqueInput>;
}

export interface ClientUpdateWithoutStudentsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface ClientUpsertWithoutStudentsInput {
  update: ClientUpdateWithoutStudentsDataInput;
  create: ClientCreateWithoutStudentsInput;
}

export interface StudentUpsertWithWhereUniqueWithoutClassesInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutClassesDataInput;
  create: StudentCreateWithoutClassesInput;
}

export interface StudentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  birthday?: Maybe<String>;
  birthday_not?: Maybe<String>;
  birthday_in?: Maybe<String[] | String>;
  birthday_not_in?: Maybe<String[] | String>;
  birthday_lt?: Maybe<String>;
  birthday_lte?: Maybe<String>;
  birthday_gt?: Maybe<String>;
  birthday_gte?: Maybe<String>;
  birthday_contains?: Maybe<String>;
  birthday_not_contains?: Maybe<String>;
  birthday_starts_with?: Maybe<String>;
  birthday_not_starts_with?: Maybe<String>;
  birthday_ends_with?: Maybe<String>;
  birthday_not_ends_with?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  skill_not?: Maybe<SkillLevel>;
  skill_in?: Maybe<SkillLevel[] | SkillLevel>;
  skill_not_in?: Maybe<SkillLevel[] | SkillLevel>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  OR?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  NOT?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
}

export interface StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput;
  data: StudentUpdateManyDataInput;
}

export interface StudentUpdateManyDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  gender?: Maybe<Gender>;
}

export interface ClassUpsertWithWhereUniqueWithoutInstructorInput {
  where: ClassWhereUniqueInput;
  update: ClassUpdateWithoutInstructorDataInput;
  create: ClassCreateWithoutInstructorInput;
}

export interface MessageUpdateManyWithoutAuthorInput {
  create?: Maybe<
    MessageCreateWithoutAuthorInput[] | MessageCreateWithoutAuthorInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutAuthorInput[]
    | MessageUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutAuthorInput[]
    | MessageUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutAuthorInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutAuthorDataInput;
}

export interface MessageUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  text?: Maybe<String>;
  parent?: Maybe<MessageUpdateOneWithoutParentInput>;
  taggedEmployees?: Maybe<EmployeeUpdateManyWithoutTaggedMessagesInput>;
  tags?: Maybe<MessageTagUpdateManyWithoutMessagesInput>;
  comments?: Maybe<MessageUpdateManyWithoutCommentsInput>;
}

export interface MessageUpdateOneWithoutParentInput {
  create?: Maybe<MessageCreateWithoutParentInput>;
  update?: Maybe<MessageUpdateWithoutParentDataInput>;
  upsert?: Maybe<MessageUpsertWithoutParentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MessageWhereUniqueInput>;
}

export interface MessageUpdateWithoutParentDataInput {
  title?: Maybe<String>;
  text?: Maybe<String>;
  author?: Maybe<EmployeeUpdateOneRequiredWithoutCreatedMessagesInput>;
  taggedEmployees?: Maybe<EmployeeUpdateManyWithoutTaggedMessagesInput>;
  tags?: Maybe<MessageTagUpdateManyWithoutMessagesInput>;
  comments?: Maybe<MessageUpdateManyWithoutCommentsInput>;
}

export interface EmployeeUpdateOneRequiredWithoutCreatedMessagesInput {
  create?: Maybe<EmployeeCreateWithoutCreatedMessagesInput>;
  update?: Maybe<EmployeeUpdateWithoutCreatedMessagesDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutCreatedMessagesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutCreatedMessagesDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<EmployeeUpdateroleInput>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  classes?: Maybe<ClassUpdateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonUpdateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedEmployeesInput>;
}

export interface LessonUpdateManyWithoutInstructorInput {
  create?: Maybe<
    LessonCreateWithoutInstructorInput[] | LessonCreateWithoutInstructorInput
  >;
  delete?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  set?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  disconnect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  update?: Maybe<
    | LessonUpdateWithWhereUniqueWithoutInstructorInput[]
    | LessonUpdateWithWhereUniqueWithoutInstructorInput
  >;
  upsert?: Maybe<
    | LessonUpsertWithWhereUniqueWithoutInstructorInput[]
    | LessonUpsertWithWhereUniqueWithoutInstructorInput
  >;
  deleteMany?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  updateMany?: Maybe<
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput
  >;
}

export interface LessonUpdateWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutInstructorDataInput;
}

export interface LessonUpdateWithoutInstructorDataInput {
  client?: Maybe<StudentUpdateManyWithoutLessonsInput>;
  duration?: Maybe<Int>;
  type?: Maybe<LessonType>;
  day?: Maybe<Day>;
  time?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface StudentUpdateManyWithoutLessonsInput {
  create?: Maybe<
    StudentCreateWithoutLessonsInput[] | StudentCreateWithoutLessonsInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueWithoutLessonsInput[]
    | StudentUpdateWithWhereUniqueWithoutLessonsInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueWithoutLessonsInput[]
    | StudentUpsertWithWhereUniqueWithoutLessonsInput
  >;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutLessonsDataInput;
}

export interface StudentUpdateWithoutLessonsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
  admin?: Maybe<ClientUpdateOneWithoutStudentsInput>;
}

export interface StudentUpsertWithWhereUniqueWithoutLessonsInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutLessonsDataInput;
  create: StudentCreateWithoutLessonsInput;
}

export interface LessonUpsertWithWhereUniqueWithoutInstructorInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutInstructorDataInput;
  create: LessonCreateWithoutInstructorInput;
}

export interface LessonScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  type?: Maybe<LessonType>;
  type_not?: Maybe<LessonType>;
  type_in?: Maybe<LessonType[] | LessonType>;
  type_not_in?: Maybe<LessonType[] | LessonType>;
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  open?: Maybe<Boolean>;
  open_not?: Maybe<Boolean>;
  AND?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  OR?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  NOT?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
}

export interface LessonUpdateManyWithWhereNestedInput {
  where: LessonScalarWhereInput;
  data: LessonUpdateManyDataInput;
}

export interface LessonUpdateManyDataInput {
  duration?: Maybe<Int>;
  type?: Maybe<LessonType>;
  day?: Maybe<Day>;
  time?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface MessageUpdateManyWithoutTaggedEmployeesInput {
  create?: Maybe<
    | MessageCreateWithoutTaggedEmployeesInput[]
    | MessageCreateWithoutTaggedEmployeesInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutTaggedEmployeesInput[]
    | MessageUpdateWithWhereUniqueWithoutTaggedEmployeesInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutTaggedEmployeesInput[]
    | MessageUpsertWithWhereUniqueWithoutTaggedEmployeesInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutTaggedEmployeesInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutTaggedEmployeesDataInput;
}

export interface MessageUpdateWithoutTaggedEmployeesDataInput {
  title?: Maybe<String>;
  text?: Maybe<String>;
  author?: Maybe<EmployeeUpdateOneRequiredWithoutCreatedMessagesInput>;
  parent?: Maybe<MessageUpdateOneWithoutParentInput>;
  tags?: Maybe<MessageTagUpdateManyWithoutMessagesInput>;
  comments?: Maybe<MessageUpdateManyWithoutCommentsInput>;
}

export interface MessageTagUpdateManyWithoutMessagesInput {
  create?: Maybe<
    | MessageTagCreateWithoutMessagesInput[]
    | MessageTagCreateWithoutMessagesInput
  >;
  delete?: Maybe<MessageTagWhereUniqueInput[] | MessageTagWhereUniqueInput>;
  connect?: Maybe<MessageTagWhereUniqueInput[] | MessageTagWhereUniqueInput>;
  set?: Maybe<MessageTagWhereUniqueInput[] | MessageTagWhereUniqueInput>;
  disconnect?: Maybe<MessageTagWhereUniqueInput[] | MessageTagWhereUniqueInput>;
  update?: Maybe<
    | MessageTagUpdateWithWhereUniqueWithoutMessagesInput[]
    | MessageTagUpdateWithWhereUniqueWithoutMessagesInput
  >;
  upsert?: Maybe<
    | MessageTagUpsertWithWhereUniqueWithoutMessagesInput[]
    | MessageTagUpsertWithWhereUniqueWithoutMessagesInput
  >;
  deleteMany?: Maybe<MessageTagScalarWhereInput[] | MessageTagScalarWhereInput>;
  updateMany?: Maybe<
    | MessageTagUpdateManyWithWhereNestedInput[]
    | MessageTagUpdateManyWithWhereNestedInput
  >;
}

export interface MessageTagUpdateWithWhereUniqueWithoutMessagesInput {
  where: MessageTagWhereUniqueInput;
  data: MessageTagUpdateWithoutMessagesDataInput;
}

export interface MessageTagUpdateWithoutMessagesDataInput {
  tag?: Maybe<String>;
}

export interface MessageTagUpsertWithWhereUniqueWithoutMessagesInput {
  where: MessageTagWhereUniqueInput;
  update: MessageTagUpdateWithoutMessagesDataInput;
  create: MessageTagCreateWithoutMessagesInput;
}

export interface MessageTagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  tag?: Maybe<String>;
  tag_not?: Maybe<String>;
  tag_in?: Maybe<String[] | String>;
  tag_not_in?: Maybe<String[] | String>;
  tag_lt?: Maybe<String>;
  tag_lte?: Maybe<String>;
  tag_gt?: Maybe<String>;
  tag_gte?: Maybe<String>;
  tag_contains?: Maybe<String>;
  tag_not_contains?: Maybe<String>;
  tag_starts_with?: Maybe<String>;
  tag_not_starts_with?: Maybe<String>;
  tag_ends_with?: Maybe<String>;
  tag_not_ends_with?: Maybe<String>;
  AND?: Maybe<MessageTagScalarWhereInput[] | MessageTagScalarWhereInput>;
  OR?: Maybe<MessageTagScalarWhereInput[] | MessageTagScalarWhereInput>;
  NOT?: Maybe<MessageTagScalarWhereInput[] | MessageTagScalarWhereInput>;
}

export interface MessageTagUpdateManyWithWhereNestedInput {
  where: MessageTagScalarWhereInput;
  data: MessageTagUpdateManyDataInput;
}

export interface MessageTagUpdateManyDataInput {
  tag?: Maybe<String>;
}

export interface MessageUpdateManyWithoutCommentsInput {
  create?: Maybe<
    MessageCreateWithoutCommentsInput[] | MessageCreateWithoutCommentsInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutCommentsInput[]
    | MessageUpdateWithWhereUniqueWithoutCommentsInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutCommentsInput[]
    | MessageUpsertWithWhereUniqueWithoutCommentsInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutCommentsInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutCommentsDataInput;
}

export interface MessageUpdateWithoutCommentsDataInput {
  title?: Maybe<String>;
  text?: Maybe<String>;
  author?: Maybe<EmployeeUpdateOneRequiredWithoutCreatedMessagesInput>;
  parent?: Maybe<MessageUpdateOneWithoutParentInput>;
  taggedEmployees?: Maybe<EmployeeUpdateManyWithoutTaggedMessagesInput>;
  tags?: Maybe<MessageTagUpdateManyWithoutMessagesInput>;
}

export interface EmployeeUpdateManyWithoutTaggedMessagesInput {
  create?: Maybe<
    | EmployeeCreateWithoutTaggedMessagesInput[]
    | EmployeeCreateWithoutTaggedMessagesInput
  >;
  delete?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  connect?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  set?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  disconnect?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  update?: Maybe<
    | EmployeeUpdateWithWhereUniqueWithoutTaggedMessagesInput[]
    | EmployeeUpdateWithWhereUniqueWithoutTaggedMessagesInput
  >;
  upsert?: Maybe<
    | EmployeeUpsertWithWhereUniqueWithoutTaggedMessagesInput[]
    | EmployeeUpsertWithWhereUniqueWithoutTaggedMessagesInput
  >;
  deleteMany?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  updateMany?: Maybe<
    | EmployeeUpdateManyWithWhereNestedInput[]
    | EmployeeUpdateManyWithWhereNestedInput
  >;
}

export interface EmployeeUpdateWithWhereUniqueWithoutTaggedMessagesInput {
  where: EmployeeWhereUniqueInput;
  data: EmployeeUpdateWithoutTaggedMessagesDataInput;
}

export interface EmployeeUpdateWithoutTaggedMessagesDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<EmployeeUpdateroleInput>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  classes?: Maybe<ClassUpdateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonUpdateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  createdMessages?: Maybe<MessageUpdateManyWithoutAuthorInput>;
}

export interface EmployeeUpsertWithWhereUniqueWithoutTaggedMessagesInput {
  where: EmployeeWhereUniqueInput;
  update: EmployeeUpdateWithoutTaggedMessagesDataInput;
  create: EmployeeCreateWithoutTaggedMessagesInput;
}

export interface EmployeeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zip?: Maybe<Int>;
  zip_not?: Maybe<Int>;
  zip_in?: Maybe<Int[] | Int>;
  zip_not_in?: Maybe<Int[] | Int>;
  zip_lt?: Maybe<Int>;
  zip_lte?: Maybe<Int>;
  zip_gt?: Maybe<Int>;
  zip_gte?: Maybe<Int>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  imageURL?: Maybe<String>;
  imageURL_not?: Maybe<String>;
  imageURL_in?: Maybe<String[] | String>;
  imageURL_not_in?: Maybe<String[] | String>;
  imageURL_lt?: Maybe<String>;
  imageURL_lte?: Maybe<String>;
  imageURL_gt?: Maybe<String>;
  imageURL_gte?: Maybe<String>;
  imageURL_contains?: Maybe<String>;
  imageURL_not_contains?: Maybe<String>;
  imageURL_starts_with?: Maybe<String>;
  imageURL_not_starts_with?: Maybe<String>;
  imageURL_ends_with?: Maybe<String>;
  imageURL_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  currentEmployee_not?: Maybe<Boolean>;
  lessonSinglePrice?: Maybe<Int>;
  lessonSinglePrice_not?: Maybe<Int>;
  lessonSinglePrice_in?: Maybe<Int[] | Int>;
  lessonSinglePrice_not_in?: Maybe<Int[] | Int>;
  lessonSinglePrice_lt?: Maybe<Int>;
  lessonSinglePrice_lte?: Maybe<Int>;
  lessonSinglePrice_gt?: Maybe<Int>;
  lessonSinglePrice_gte?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  lessonDoublePrice_not?: Maybe<Int>;
  lessonDoublePrice_in?: Maybe<Int[] | Int>;
  lessonDoublePrice_not_in?: Maybe<Int[] | Int>;
  lessonDoublePrice_lt?: Maybe<Int>;
  lessonDoublePrice_lte?: Maybe<Int>;
  lessonDoublePrice_gt?: Maybe<Int>;
  lessonDoublePrice_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  OR?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  NOT?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
}

export interface EmployeeUpdateManyWithWhereNestedInput {
  where: EmployeeScalarWhereInput;
  data: EmployeeUpdateManyDataInput;
}

export interface EmployeeUpdateManyDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<EmployeeUpdateroleInput>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
}

export interface MessageUpsertWithWhereUniqueWithoutCommentsInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutCommentsDataInput;
  create: MessageCreateWithoutCommentsInput;
}

export interface MessageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface MessageUpdateManyDataInput {
  title?: Maybe<String>;
  text?: Maybe<String>;
}

export interface MessageUpsertWithWhereUniqueWithoutTaggedEmployeesInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutTaggedEmployeesDataInput;
  create: MessageCreateWithoutTaggedEmployeesInput;
}

export interface EmployeeUpsertWithoutCreatedMessagesInput {
  update: EmployeeUpdateWithoutCreatedMessagesDataInput;
  create: EmployeeCreateWithoutCreatedMessagesInput;
}

export interface MessageUpsertWithoutParentInput {
  update: MessageUpdateWithoutParentDataInput;
  create: MessageCreateWithoutParentInput;
}

export interface MessageUpsertWithWhereUniqueWithoutAuthorInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutAuthorDataInput;
  create: MessageCreateWithoutAuthorInput;
}

export interface EmployeeUpsertWithoutLessonsInput {
  update: EmployeeUpdateWithoutLessonsDataInput;
  create: EmployeeCreateWithoutLessonsInput;
}

export interface LessonUpsertWithWhereUniqueWithoutClientInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutClientDataInput;
  create: LessonCreateWithoutClientInput;
}

export interface StudentUpsertWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateDataInput;
  create: StudentCreateInput;
}

export interface EmployeeUpsertWithoutClassesInput {
  update: EmployeeUpdateWithoutClassesDataInput;
  create: EmployeeCreateWithoutClassesInput;
}

export interface ClassUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  level?: Maybe<SkillLevel>;
  capacity?: Maybe<Int>;
  price?: Maybe<Int>;
  day?: Maybe<Day>;
  duration?: Maybe<Int>;
  time?: Maybe<String>;
}

export interface ClientCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  students?: Maybe<StudentCreateManyWithoutAdminInput>;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface StudentCreateManyWithoutAdminInput {
  create?: Maybe<
    StudentCreateWithoutAdminInput[] | StudentCreateWithoutAdminInput
  >;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
}

export interface StudentCreateWithoutAdminInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: Maybe<ClassCreateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonCreateManyWithoutClientInput>;
  gender: Gender;
  medical?: Maybe<MedicalConditionCreateManyWithoutStudentInput>;
}

export interface ClientUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  students?: Maybe<StudentUpdateManyWithoutAdminInput>;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface StudentUpdateManyWithoutAdminInput {
  create?: Maybe<
    StudentCreateWithoutAdminInput[] | StudentCreateWithoutAdminInput
  >;
  delete?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  connect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  set?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  disconnect?: Maybe<StudentWhereUniqueInput[] | StudentWhereUniqueInput>;
  update?: Maybe<
    | StudentUpdateWithWhereUniqueWithoutAdminInput[]
    | StudentUpdateWithWhereUniqueWithoutAdminInput
  >;
  upsert?: Maybe<
    | StudentUpsertWithWhereUniqueWithoutAdminInput[]
    | StudentUpsertWithWhereUniqueWithoutAdminInput
  >;
  deleteMany?: Maybe<StudentScalarWhereInput[] | StudentScalarWhereInput>;
  updateMany?: Maybe<
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput
  >;
}

export interface StudentUpdateWithWhereUniqueWithoutAdminInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutAdminDataInput;
}

export interface StudentUpdateWithoutAdminDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
}

export interface StudentUpsertWithWhereUniqueWithoutAdminInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutAdminDataInput;
  create: StudentCreateWithoutAdminInput;
}

export interface ClientUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phone?: Maybe<String>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  stripeId?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<String>;
}

export interface EmployeeCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role?: Maybe<EmployeeCreateroleInput>;
  imageURL: String;
  startDate: DateTimeInput;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentCreateManyInput>;
  classes?: Maybe<ClassCreateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonCreateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  createdMessages?: Maybe<MessageCreateManyWithoutAuthorInput>;
  taggedMessages?: Maybe<MessageCreateManyWithoutTaggedEmployeesInput>;
}

export interface EmployeeUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<EmployeeUpdateroleInput>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  clients?: Maybe<StudentUpdateManyInput>;
  classes?: Maybe<ClassUpdateManyWithoutInstructorInput>;
  lessons?: Maybe<LessonUpdateManyWithoutInstructorInput>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
  createdMessages?: Maybe<MessageUpdateManyWithoutAuthorInput>;
  taggedMessages?: Maybe<MessageUpdateManyWithoutTaggedEmployeesInput>;
}

export interface EmployeeUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zip?: Maybe<Int>;
  bio?: Maybe<String>;
  role?: Maybe<EmployeeUpdateroleInput>;
  imageURL?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  currentEmployee?: Maybe<Boolean>;
  lessonSinglePrice?: Maybe<Int>;
  lessonDoublePrice?: Maybe<Int>;
}

export interface LessonCreateInput {
  id?: Maybe<ID_Input>;
  instructor: EmployeeCreateOneWithoutLessonsInput;
  client?: Maybe<StudentCreateManyWithoutLessonsInput>;
  duration: Int;
  type?: Maybe<LessonType>;
  day: Day;
  time: String;
  open: Boolean;
}

export interface LessonUpdateInput {
  instructor?: Maybe<EmployeeUpdateOneRequiredWithoutLessonsInput>;
  client?: Maybe<StudentUpdateManyWithoutLessonsInput>;
  duration?: Maybe<Int>;
  type?: Maybe<LessonType>;
  day?: Maybe<Day>;
  time?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface LessonUpdateManyMutationInput {
  duration?: Maybe<Int>;
  type?: Maybe<LessonType>;
  day?: Maybe<Day>;
  time?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface MedicalConditionCreateInput {
  id?: Maybe<ID_Input>;
  description: String;
  student?: Maybe<StudentCreateOneWithoutMedicalInput>;
}

export interface StudentCreateOneWithoutMedicalInput {
  create?: Maybe<StudentCreateWithoutMedicalInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface StudentCreateWithoutMedicalInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  ageGroup: AgeGroupCreateOneInput;
  classes?: Maybe<ClassCreateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonCreateManyWithoutClientInput>;
  gender: Gender;
  admin?: Maybe<ClientCreateOneWithoutStudentsInput>;
}

export interface MedicalConditionUpdateInput {
  description?: Maybe<String>;
  student?: Maybe<StudentUpdateOneWithoutMedicalInput>;
}

export interface StudentUpdateOneWithoutMedicalInput {
  create?: Maybe<StudentCreateWithoutMedicalInput>;
  update?: Maybe<StudentUpdateWithoutMedicalDataInput>;
  upsert?: Maybe<StudentUpsertWithoutMedicalInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface StudentUpdateWithoutMedicalDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  admin?: Maybe<ClientUpdateOneWithoutStudentsInput>;
}

export interface StudentUpsertWithoutMedicalInput {
  update: StudentUpdateWithoutMedicalDataInput;
  create: StudentCreateWithoutMedicalInput;
}

export interface MedicalConditionUpdateManyMutationInput {
  description?: Maybe<String>;
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  text: String;
  author: EmployeeCreateOneWithoutCreatedMessagesInput;
  parent?: Maybe<MessageCreateOneWithoutParentInput>;
  taggedEmployees?: Maybe<EmployeeCreateManyWithoutTaggedMessagesInput>;
  tags?: Maybe<MessageTagCreateManyWithoutMessagesInput>;
  comments?: Maybe<MessageCreateManyWithoutCommentsInput>;
}

export interface MessageUpdateInput {
  title?: Maybe<String>;
  text?: Maybe<String>;
  author?: Maybe<EmployeeUpdateOneRequiredWithoutCreatedMessagesInput>;
  parent?: Maybe<MessageUpdateOneWithoutParentInput>;
  taggedEmployees?: Maybe<EmployeeUpdateManyWithoutTaggedMessagesInput>;
  tags?: Maybe<MessageTagUpdateManyWithoutMessagesInput>;
  comments?: Maybe<MessageUpdateManyWithoutCommentsInput>;
}

export interface MessageUpdateManyMutationInput {
  title?: Maybe<String>;
  text?: Maybe<String>;
}

export interface MessageTagCreateInput {
  id?: Maybe<ID_Input>;
  tag: String;
  messages?: Maybe<MessageCreateManyWithoutTagsInput>;
}

export interface MessageCreateManyWithoutTagsInput {
  create?: Maybe<
    MessageCreateWithoutTagsInput[] | MessageCreateWithoutTagsInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutTagsInput {
  id?: Maybe<ID_Input>;
  title: String;
  text: String;
  author: EmployeeCreateOneWithoutCreatedMessagesInput;
  parent?: Maybe<MessageCreateOneWithoutParentInput>;
  taggedEmployees?: Maybe<EmployeeCreateManyWithoutTaggedMessagesInput>;
  comments?: Maybe<MessageCreateManyWithoutCommentsInput>;
}

export interface MessageTagUpdateInput {
  tag?: Maybe<String>;
  messages?: Maybe<MessageUpdateManyWithoutTagsInput>;
}

export interface MessageUpdateManyWithoutTagsInput {
  create?: Maybe<
    MessageCreateWithoutTagsInput[] | MessageCreateWithoutTagsInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutTagsInput[]
    | MessageUpdateWithWhereUniqueWithoutTagsInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutTagsInput[]
    | MessageUpsertWithWhereUniqueWithoutTagsInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutTagsInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutTagsDataInput;
}

export interface MessageUpdateWithoutTagsDataInput {
  title?: Maybe<String>;
  text?: Maybe<String>;
  author?: Maybe<EmployeeUpdateOneRequiredWithoutCreatedMessagesInput>;
  parent?: Maybe<MessageUpdateOneWithoutParentInput>;
  taggedEmployees?: Maybe<EmployeeUpdateManyWithoutTaggedMessagesInput>;
  comments?: Maybe<MessageUpdateManyWithoutCommentsInput>;
}

export interface MessageUpsertWithWhereUniqueWithoutTagsInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutTagsDataInput;
  create: MessageCreateWithoutTagsInput;
}

export interface MessageTagUpdateManyMutationInput {
  tag?: Maybe<String>;
}

export interface StudentUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  ageGroup?: Maybe<AgeGroupUpdateOneRequiredInput>;
  classes?: Maybe<ClassUpdateManyWithoutStudentsInput>;
  lessons?: Maybe<LessonUpdateManyWithoutClientInput>;
  gender?: Maybe<Gender>;
  medical?: Maybe<MedicalConditionUpdateManyWithoutStudentInput>;
  admin?: Maybe<ClientUpdateOneWithoutStudentsInput>;
}

export interface StudentUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  birthday?: Maybe<String>;
  skill?: Maybe<SkillLevel>;
  gender?: Maybe<Gender>;
}

export interface AgeGroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AgeGroupWhereInput>;
  AND?: Maybe<
    AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput
  >;
  OR?: Maybe<AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput>;
  NOT?: Maybe<
    AgeGroupSubscriptionWhereInput[] | AgeGroupSubscriptionWhereInput
  >;
}

export interface ClassSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClassWhereInput>;
  AND?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
  OR?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
  NOT?: Maybe<ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput>;
}

export interface ClientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClientWhereInput>;
  AND?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  OR?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  NOT?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeeWhereInput>;
  AND?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
  OR?: Maybe<EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput>;
  NOT?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
}

export interface LessonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LessonWhereInput>;
  AND?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
  OR?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
  NOT?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
}

export interface MedicalConditionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MedicalConditionWhereInput>;
  AND?: Maybe<
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MedicalConditionSubscriptionWhereInput[]
    | MedicalConditionSubscriptionWhereInput
  >;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface MessageTagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageTagWhereInput>;
  AND?: Maybe<
    MessageTagSubscriptionWhereInput[] | MessageTagSubscriptionWhereInput
  >;
  OR?: Maybe<
    MessageTagSubscriptionWhereInput[] | MessageTagSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MessageTagSubscriptionWhereInput[] | MessageTagSubscriptionWhereInput
  >;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudentWhereInput>;
  AND?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
  OR?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
  NOT?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AgeGroup {
  id: ID_Output;
  name: String;
  minAge: Int;
  maxAge?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AgeGroupPromise extends Promise<AgeGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupSubscription
  extends Promise<AsyncIterator<AgeGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  minAge: () => Promise<AsyncIterator<Int>>;
  maxAge: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AgeGroupNullablePromise
  extends Promise<AgeGroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupConnection {
  pageInfo: PageInfo;
  edges: AgeGroupEdge[];
}

export interface AgeGroupConnectionPromise
  extends Promise<AgeGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgeGroupEdge>>() => T;
  aggregate: <T = AggregateAgeGroupPromise>() => T;
}

export interface AgeGroupConnectionSubscription
  extends Promise<AsyncIterator<AgeGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgeGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgeGroupSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AgeGroupEdge {
  node: AgeGroup;
  cursor: String;
}

export interface AgeGroupEdgePromise
  extends Promise<AgeGroupEdge>,
    Fragmentable {
  node: <T = AgeGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgeGroupEdgeSubscription
  extends Promise<AsyncIterator<AgeGroupEdge>>,
    Fragmentable {
  node: <T = AgeGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAgeGroup {
  count: Int;
}

export interface AggregateAgeGroupPromise
  extends Promise<AggregateAgeGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgeGroupSubscription
  extends Promise<AsyncIterator<AggregateAgeGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Class {
  id: ID_Output;
  name?: String;
  description: String;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  time: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPromise extends Promise<Class>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  ageGroup: <T = AgeGroupPromise>() => T;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  instructor: <T = EmployeePromise>() => T;
  duration: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassSubscription
  extends Promise<AsyncIterator<Class>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  ageGroup: <T = AgeGroupSubscription>() => T;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  instructor: <T = EmployeeSubscription>() => T;
  duration: () => Promise<AsyncIterator<Int>>;
  students: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassNullablePromise
  extends Promise<Class | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  ageGroup: <T = AgeGroupPromise>() => T;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  instructor: <T = EmployeePromise>() => T;
  duration: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  time: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Employee {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role[];
  imageURL: String;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role[]>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  clients: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessonSinglePrice: () => Promise<Int>;
  lessonDoublePrice: () => Promise<Int>;
  createdMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  taggedMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  bio: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role[]>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  clients: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessonSinglePrice: () => Promise<AsyncIterator<Int>>;
  lessonDoublePrice: () => Promise<AsyncIterator<Int>>;
  createdMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  taggedMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeeNullablePromise
  extends Promise<Employee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role[]>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  clients: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessonSinglePrice: () => Promise<Int>;
  lessonDoublePrice: () => Promise<Int>;
  createdMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  taggedMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Student {
  id: ID_Output;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  gender: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  skill: () => Promise<SkillLevel>;
  ageGroup: <T = AgeGroupPromise>() => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<Gender>;
  medical: <T = FragmentableArray<MedicalCondition>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admin: <T = ClientPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  skill: () => Promise<AsyncIterator<SkillLevel>>;
  ageGroup: <T = AgeGroupSubscription>() => T;
  classes: <T = Promise<AsyncIterator<ClassSubscription>>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<AsyncIterator<Gender>>;
  medical: <T = Promise<AsyncIterator<MedicalConditionSubscription>>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admin: <T = ClientSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudentNullablePromise
  extends Promise<Student | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  skill: () => Promise<SkillLevel>;
  ageGroup: <T = AgeGroupPromise>() => T;
  classes: <T = FragmentableArray<Class>>(args?: {
    where?: ClassWhereInput;
    orderBy?: ClassOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gender: () => Promise<Gender>;
  medical: <T = FragmentableArray<MedicalCondition>>(args?: {
    where?: MedicalConditionWhereInput;
    orderBy?: MedicalConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admin: <T = ClientPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Lesson {
  id: ID_Output;
  duration: Int;
  type?: LessonType;
  day: Day;
  time: String;
  open: Boolean;
}

export interface LessonPromise extends Promise<Lesson>, Fragmentable {
  id: () => Promise<ID_Output>;
  instructor: <T = EmployeePromise>() => T;
  client: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Int>;
  type: () => Promise<LessonType>;
  day: () => Promise<Day>;
  time: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface LessonSubscription
  extends Promise<AsyncIterator<Lesson>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  instructor: <T = EmployeeSubscription>() => T;
  client: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<LessonType>>;
  day: () => Promise<AsyncIterator<Day>>;
  time: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface LessonNullablePromise
  extends Promise<Lesson | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  instructor: <T = EmployeePromise>() => T;
  client: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Int>;
  type: () => Promise<LessonType>;
  day: () => Promise<Day>;
  time: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface MedicalCondition {
  id: ID_Output;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicalConditionPromise
  extends Promise<MedicalCondition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  student: <T = StudentPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicalConditionSubscription
  extends Promise<AsyncIterator<MedicalCondition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  student: <T = StudentSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MedicalConditionNullablePromise
  extends Promise<MedicalCondition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  student: <T = StudentPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Client {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClientPromise extends Promise<Client>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClientSubscription
  extends Promise<AsyncIterator<Client>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  students: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClientNullablePromise
  extends Promise<Client | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  students: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Message {
  id: ID_Output;
  title: String;
  text: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  author: <T = EmployeePromise>() => T;
  parent: <T = MessagePromise>() => T;
  taggedEmployees: <T = FragmentableArray<Employee>>(args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<MessageTag>>(args?: {
    where?: MessageTagWhereInput;
    orderBy?: MessageTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  author: <T = EmployeeSubscription>() => T;
  parent: <T = MessageSubscription>() => T;
  taggedEmployees: <T = Promise<AsyncIterator<EmployeeSubscription>>>(args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<MessageTagSubscription>>>(args?: {
    where?: MessageTagWhereInput;
    orderBy?: MessageTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  author: <T = EmployeePromise>() => T;
  parent: <T = MessagePromise>() => T;
  taggedEmployees: <T = FragmentableArray<Employee>>(args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<MessageTag>>(args?: {
    where?: MessageTagWhereInput;
    orderBy?: MessageTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MessageTag {
  id: ID_Output;
  tag: String;
}

export interface MessageTagPromise extends Promise<MessageTag>, Fragmentable {
  id: () => Promise<ID_Output>;
  tag: () => Promise<String>;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MessageTagSubscription
  extends Promise<AsyncIterator<MessageTag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  tag: () => Promise<AsyncIterator<String>>;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MessageTagNullablePromise
  extends Promise<MessageTag | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  tag: () => Promise<String>;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClassConnection {
  pageInfo: PageInfo;
  edges: ClassEdge[];
}

export interface ClassConnectionPromise
  extends Promise<ClassConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassEdge>>() => T;
  aggregate: <T = AggregateClassPromise>() => T;
}

export interface ClassConnectionSubscription
  extends Promise<AsyncIterator<ClassConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassSubscription>() => T;
}

export interface ClassEdge {
  node: Class;
  cursor: String;
}

export interface ClassEdgePromise extends Promise<ClassEdge>, Fragmentable {
  node: <T = ClassPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassEdgeSubscription
  extends Promise<AsyncIterator<ClassEdge>>,
    Fragmentable {
  node: <T = ClassSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClass {
  count: Int;
}

export interface AggregateClassPromise
  extends Promise<AggregateClass>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassSubscription
  extends Promise<AsyncIterator<AggregateClass>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClientConnection {
  pageInfo: PageInfo;
  edges: ClientEdge[];
}

export interface ClientConnectionPromise
  extends Promise<ClientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClientEdge>>() => T;
  aggregate: <T = AggregateClientPromise>() => T;
}

export interface ClientConnectionSubscription
  extends Promise<AsyncIterator<ClientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClientSubscription>() => T;
}

export interface ClientEdge {
  node: Client;
  cursor: String;
}

export interface ClientEdgePromise extends Promise<ClientEdge>, Fragmentable {
  node: <T = ClientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClientEdgeSubscription
  extends Promise<AsyncIterator<ClientEdge>>,
    Fragmentable {
  node: <T = ClientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClient {
  count: Int;
}

export interface AggregateClientPromise
  extends Promise<AggregateClient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClientSubscription
  extends Promise<AsyncIterator<AggregateClient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeConnection {
  pageInfo: PageInfo;
  edges: EmployeeEdge[];
}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface EmployeeEdge {
  node: Employee;
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LessonConnection {
  pageInfo: PageInfo;
  edges: LessonEdge[];
}

export interface LessonConnectionPromise
  extends Promise<LessonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LessonEdge>>() => T;
  aggregate: <T = AggregateLessonPromise>() => T;
}

export interface LessonConnectionSubscription
  extends Promise<AsyncIterator<LessonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LessonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLessonSubscription>() => T;
}

export interface LessonEdge {
  node: Lesson;
  cursor: String;
}

export interface LessonEdgePromise extends Promise<LessonEdge>, Fragmentable {
  node: <T = LessonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LessonEdgeSubscription
  extends Promise<AsyncIterator<LessonEdge>>,
    Fragmentable {
  node: <T = LessonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLesson {
  count: Int;
}

export interface AggregateLessonPromise
  extends Promise<AggregateLesson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLessonSubscription
  extends Promise<AsyncIterator<AggregateLesson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MedicalConditionConnection {
  pageInfo: PageInfo;
  edges: MedicalConditionEdge[];
}

export interface MedicalConditionConnectionPromise
  extends Promise<MedicalConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MedicalConditionEdge>>() => T;
  aggregate: <T = AggregateMedicalConditionPromise>() => T;
}

export interface MedicalConditionConnectionSubscription
  extends Promise<AsyncIterator<MedicalConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MedicalConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMedicalConditionSubscription>() => T;
}

export interface MedicalConditionEdge {
  node: MedicalCondition;
  cursor: String;
}

export interface MedicalConditionEdgePromise
  extends Promise<MedicalConditionEdge>,
    Fragmentable {
  node: <T = MedicalConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MedicalConditionEdgeSubscription
  extends Promise<AsyncIterator<MedicalConditionEdge>>,
    Fragmentable {
  node: <T = MedicalConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMedicalCondition {
  count: Int;
}

export interface AggregateMedicalConditionPromise
  extends Promise<AggregateMedicalCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMedicalConditionSubscription
  extends Promise<AsyncIterator<AggregateMedicalCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageTagConnection {
  pageInfo: PageInfo;
  edges: MessageTagEdge[];
}

export interface MessageTagConnectionPromise
  extends Promise<MessageTagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageTagEdge>>() => T;
  aggregate: <T = AggregateMessageTagPromise>() => T;
}

export interface MessageTagConnectionSubscription
  extends Promise<AsyncIterator<MessageTagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageTagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageTagSubscription>() => T;
}

export interface MessageTagEdge {
  node: MessageTag;
  cursor: String;
}

export interface MessageTagEdgePromise
  extends Promise<MessageTagEdge>,
    Fragmentable {
  node: <T = MessageTagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageTagEdgeSubscription
  extends Promise<AsyncIterator<MessageTagEdge>>,
    Fragmentable {
  node: <T = MessageTagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessageTag {
  count: Int;
}

export interface AggregateMessageTagPromise
  extends Promise<AggregateMessageTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageTagSubscription
  extends Promise<AsyncIterator<AggregateMessageTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AgeGroupSubscriptionPayload {
  mutation: MutationType;
  node: AgeGroup;
  updatedFields: String[];
  previousValues: AgeGroupPreviousValues;
}

export interface AgeGroupSubscriptionPayloadPromise
  extends Promise<AgeGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgeGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgeGroupPreviousValuesPromise>() => T;
}

export interface AgeGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgeGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgeGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgeGroupPreviousValuesSubscription>() => T;
}

export interface AgeGroupPreviousValues {
  id: ID_Output;
  name: String;
  minAge: Int;
  maxAge?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AgeGroupPreviousValuesPromise
  extends Promise<AgeGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  minAge: () => Promise<Int>;
  maxAge: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AgeGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<AgeGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  minAge: () => Promise<AsyncIterator<Int>>;
  maxAge: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassSubscriptionPayload {
  mutation: MutationType;
  node: Class;
  updatedFields: String[];
  previousValues: ClassPreviousValues;
}

export interface ClassSubscriptionPayloadPromise
  extends Promise<ClassSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassPreviousValuesPromise>() => T;
}

export interface ClassSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassPreviousValuesSubscription>() => T;
}

export interface ClassPreviousValues {
  id: ID_Output;
  name?: String;
  description: String;
  level: SkillLevel;
  capacity: Int;
  price: Int;
  day: Day;
  duration: Int;
  time: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClassPreviousValuesPromise
  extends Promise<ClassPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  level: () => Promise<SkillLevel>;
  capacity: () => Promise<Int>;
  price: () => Promise<Int>;
  day: () => Promise<Day>;
  duration: () => Promise<Int>;
  time: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClassPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<SkillLevel>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  day: () => Promise<AsyncIterator<Day>>;
  duration: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClientSubscriptionPayload {
  mutation: MutationType;
  node: Client;
  updatedFields: String[];
  previousValues: ClientPreviousValues;
}

export interface ClientSubscriptionPayloadPromise
  extends Promise<ClientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClientPreviousValuesPromise>() => T;
}

export interface ClientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClientPreviousValuesSubscription>() => T;
}

export interface ClientPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  firstName: String;
  lastName: String;
  phone: String;
  address: String;
  city: String;
  state: String;
  zip: Int;
  stripeId?: String;
  resetToken?: String;
  resetTokenExpiry?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ClientPreviousValuesPromise
  extends Promise<ClientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  stripeId: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ClientPreviousValuesSubscription
  extends Promise<AsyncIterator<ClientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  stripeId: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  node: Employee;
  updatedFields: String[];
  previousValues: EmployeePreviousValues;
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface EmployeePreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  firstName: String;
  lastName: String;
  gender: Gender;
  address: String;
  city: String;
  state: String;
  zip: Int;
  bio: String;
  role: Role[];
  imageURL: String;
  startDate: DateTimeOutput;
  currentEmployee: Boolean;
  lessonSinglePrice?: Int;
  lessonDoublePrice?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<Int>;
  bio: () => Promise<String>;
  role: () => Promise<Role[]>;
  imageURL: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  currentEmployee: () => Promise<Boolean>;
  lessonSinglePrice: () => Promise<Int>;
  lessonDoublePrice: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<Int>>;
  bio: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role[]>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currentEmployee: () => Promise<AsyncIterator<Boolean>>;
  lessonSinglePrice: () => Promise<AsyncIterator<Int>>;
  lessonDoublePrice: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LessonSubscriptionPayload {
  mutation: MutationType;
  node: Lesson;
  updatedFields: String[];
  previousValues: LessonPreviousValues;
}

export interface LessonSubscriptionPayloadPromise
  extends Promise<LessonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LessonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LessonPreviousValuesPromise>() => T;
}

export interface LessonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LessonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LessonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LessonPreviousValuesSubscription>() => T;
}

export interface LessonPreviousValues {
  id: ID_Output;
  duration: Int;
  type?: LessonType;
  day: Day;
  time: String;
  open: Boolean;
}

export interface LessonPreviousValuesPromise
  extends Promise<LessonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  duration: () => Promise<Int>;
  type: () => Promise<LessonType>;
  day: () => Promise<Day>;
  time: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface LessonPreviousValuesSubscription
  extends Promise<AsyncIterator<LessonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  duration: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<LessonType>>;
  day: () => Promise<AsyncIterator<Day>>;
  time: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface MedicalConditionSubscriptionPayload {
  mutation: MutationType;
  node: MedicalCondition;
  updatedFields: String[];
  previousValues: MedicalConditionPreviousValues;
}

export interface MedicalConditionSubscriptionPayloadPromise
  extends Promise<MedicalConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MedicalConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MedicalConditionPreviousValuesPromise>() => T;
}

export interface MedicalConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MedicalConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MedicalConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MedicalConditionPreviousValuesSubscription>() => T;
}

export interface MedicalConditionPreviousValues {
  id: ID_Output;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicalConditionPreviousValuesPromise
  extends Promise<MedicalConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicalConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<MedicalConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface MessagePreviousValues {
  id: ID_Output;
  title: String;
  text: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageTagSubscriptionPayload {
  mutation: MutationType;
  node: MessageTag;
  updatedFields: String[];
  previousValues: MessageTagPreviousValues;
}

export interface MessageTagSubscriptionPayloadPromise
  extends Promise<MessageTagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessageTagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessageTagPreviousValuesPromise>() => T;
}

export interface MessageTagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageTagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageTagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessageTagPreviousValuesSubscription>() => T;
}

export interface MessageTagPreviousValues {
  id: ID_Output;
  tag: String;
}

export interface MessageTagPreviousValuesPromise
  extends Promise<MessageTagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  tag: () => Promise<String>;
}

export interface MessageTagPreviousValuesSubscription
  extends Promise<AsyncIterator<MessageTagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  tag: () => Promise<AsyncIterator<String>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  birthday: String;
  skill: SkillLevel;
  gender: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  birthday: () => Promise<String>;
  skill: () => Promise<SkillLevel>;
  gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  skill: () => Promise<AsyncIterator<SkillLevel>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "SkillLevel",
    embedded: false
  },
  {
    name: "LessonType",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "Client",
    embedded: false
  },
  {
    name: "Employee",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "MessageTag",
    embedded: false
  },
  {
    name: "MedicalCondition",
    embedded: false
  },
  {
    name: "Class",
    embedded: false
  },
  {
    name: "Lesson",
    embedded: false
  },
  {
    name: "AgeGroup",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
